---
title: "Accurate sample deconvolution of pooled snRNA-seq using sex-dependent gene expression patterns"
author: "Guy Twa, Robert A. Phillips III, Nathaniel J. Robinson, Jeremy J. Day"
format: 
    html:
        toc: true
        toc-depth: 3
        toc-location: left
        max-width: "1400px"
        embed-resources: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

# Abstract
Single nucleus RNA sequencing (snRNA-seq) technology offers unprecedented resolution for studying cell type-specific gene expression patterns. However, snRNA-seq poses high costs and technical limitations, often requiring the pooling of independent biological samples and loss of individual sample-level data. Deconvolution of sample identity using inherent features would enable the incorporation of pooled barcoding and sequencing protocols, thereby increasing data throughput and analytical sample size without requiring increases in experimental sample size and sequencing costs. In this study, we demonstrate a proof of concept that sex-dependent gene expression patterns can be leveraged for the deconvolution of pooled snRNA-seq data. Using previously published snRNA-seq data from the rat ventral tegmental area, we trained a range of machine learning models to classify cell sex using genes differentially expressed in cells from male and female rats. Models that used sex-dependent gene expression predicted cell sex with high accuracy (90-92%) and outperformed simple classification models using only sex chromosome gene expression (69-89%). The generalizability of these models to other brain regions was assessed using an additional published data set from the rat nucleus accumbens. Within this data set, model performance remained highly accurate in cell sex classification (89-90% accuracy) with no additional re-training. This work provides a model for future snRNA-seq studies to perform sample deconvolution using a two-sex pooled sample sequencing design and benchmarks the performance of various machine learning approaches to deconvolve sample identification from inherent sample features.


## Document details
This file documents the workflow and code used to perfrom the analyses detailed in the manuscript *Accurate sample deconvolution of pooled snRNA-seq using sex-dependent gene expression patterns*. Briefly previously published snRNA-seq data from the rat ventral tegmental area ([Phillips, Tuscher et al., 2022](https://doi.org/10.1016/j.celrep.2022.110616)), containing both male and female samples, was used to train and evaluate machine learning (ML) and non-ML models for cell sex classification. Furthermore, model performance was evaluated on an additional published data set from the rat nucleus accumbens([Phillips et al., 2023](https://doi.org/10.1016/j.mcn.2023.103849)). Data from these previous publications may be accessed via their GEO accessions GSE168156, GSE137763, and GSE222418. 

Each section contains an `R` chunk that corresponds to an independent `.R` script outside of this document. Instead of evaluating these code chunks within this document. `R` scripts were submitted as independent batch jobs to the UAB Cheaha Research Computing cluster using the respective `.sh` Bash script following each `R` chunk.

For clarity, all code chunks are named according to their respective file names outside this document.

:::{.callout-note}
Original file paths and user emails within code chunks have been altered from the original analysis run.
:::

# Analysis
## Creating training and testing partitions
We begin analysis with the integrated VTA object previously generated by [Phillips, Tuscher et al., 2022](https://doi.org/10.1016/j.celrep.2022.110616). For this experiment, samples from three rats of the same sex were pooled within each GEM well. This experimental design enables us to train supervised models with a reliable ground-truth for cell sex classifications.

Count data for this object has already been integrated, normalized, and scaled and is stored in the 'RNA' assay 'data' slot. This saves us from having to do much pre-processing of the count data. However, we still need to prepare training and testing splits of the data. Defining this partition before all else is important to the integrity of our model assessment. If information from the testing set is allowed to inform any of our feature selection and model building workflow, the evaluation will overestimate performance. We'll use the `caret` packages `createDataPartition()` function to create a 70:30 training:testing split of our data set. To ensure that we preserve the distribution of cell type and sex as our original data set, we'll create a concatenated "CellType_Sex" metadata variable to use when splitting our data.

```{r filename="create_splits.R"}
# Setup ####
## libraries
library(Seurat)
library(tidyverse)
library(caret)

## seed
set.seed(1234)

## data
Rn7_VTA <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA.RDS")

# Create split ####
## make celltype sex combination column
Rn7_VTA$CellType_Sex <- paste(Rn7_VTA$CellType,Rn7_VTA$Sex,sep = "_")

## create partition of training and test data
trainingIndex <- createDataPartition(Rn7_VTA$CellType_Sex, p = .7, 
                                     list = FALSE, 
                                     times = 1)

training.df <- Rn7_VTA@meta.data[trainingIndex,]
testing.df <- Rn7_VTA@meta.data[-trainingIndex,]

training_cells <- rownames(training.df)
testing_cells <- rownames(testing.df)

## make summary table of the number and proportion of cell type and sex 
summary.df <- table(Rn7_VTA$CellType_Sex) %>% as.data.frame()
summary.df$prop <- summary.df$Freq/sum(summary.df$Freq)

summary.df$N_cells_train <- data.frame(table(training.df$CellType_Sex))$Freq
summary.df$Proportion_train <- summary.df$N_cells_train/sum(summary.df$N_cells_train)

summary.df$N_cells_test <- data.frame(table(testing.df$CellType_Sex))$Freq
summary.df$Proportion_test <- summary.df$N_cells_test/sum(summary.df$N_cells_test)

## make subset objects
### make cell name a metadata column
Rn7_VTA@meta.data$CellName <- rownames(Rn7_VTA@meta.data)

Rn7_VTA_training <- subset(Rn7_VTA, subset = CellName %in% training_cells)
Rn7_VTA_testing <- subset(Rn7_VTA, subset = CellName %in% testing_cells)

# Save outputs ####
## save summary table
write.csv(summary.df, file = "/path/to/sex_prediction_model/data/CellType_Sex_split_summary.csv")

## save cell split vectors
saveRDS(training_cells, file = "/path/to/sex_prediction_model/data/traincell_vector.RDS")
saveRDS(testing_cells, file = "/path/to/sex_prediction_model/data/testcell_vector.RDS")

## save Rn7 training and testing objects 
saveRDS(Rn7_VTA_training, file = "/path/to/sex_prediction_model/data/Rn7_VTA_training.RDS")
saveRDS(Rn7_VTA_testing, file = "/path/to/sex_prediction_model/data/Rn7_VTA_testing.RDS")

# sessionInfo ####
sessionInfo()
```

```{bash filename="create_splits_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=create_splits
#SBATCH --output=/path/to/sex_prediction_model/logs/create_splits_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/create_splits_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/create_splits.R
```


## Feature selection
When building our model, we need to determine what features (in this case, genes or transcripts) will be included as predictors of our outcome variable (in this case, sex). While intuition may be that more data is always better, in reality it is often the case that having a few powerful predictive features lead to better performance than many weak predictors. This is in part due to the fact that predictors with weak or no relation to the outcome variable will contribute noise and hinder prediction.

There are a number of methods for feature selection. For this analysis we use differential expression analysis to identify genes with significant sex dependent expression, and further narrow this using the wrapper feature selection method `Boruta` to find important predictors. Boruta will create "shadow" features by shuffling the values of our real features and iteratively building random forest classifiers with the combined set of real and shadow features. After each iteration, it will compare the importance scores of each feature and "reject" or "confirm" the real features which are significantly less or more important than the best performing shadow feature.


### Sex differential expression
Differentially expressed genes (DEGs) between male and female cells within the VTA snRNA-seq training data were determined for each cell type by the Wilcoxon Rank Sum test implemented in the `FindMarkers()` function from `Seurat` with default parameters. Significant DEGs were identified as those with Bonferroni-adjusted p-values < 0.05 in at least one cell type.

```{r filename="sex_differential_expression.R"}
# Setup ####
## libraries
library(Seurat)
#library(rtracklayer) #required, but we will only be using the import function
library(tidyverse)

## seed
set.seed(1234)

## data
### training object
Rn7_VTA <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA_training.RDS")
### Rn7 gene names
Rn7_gtf <- rtracklayer::import("/path/to/sex_prediction_model/data/Rattus_norvegicus.mRatBN7.2.105.gtf")
Rn7_gtf <- as.data.frame(Rn7_gtf)

# Differential Expression ####
## data setup
### set identities for cells
Idents(Rn7_VTA) <- Rn7_VTA$CellType_Sex

### initialize results list
Sex_DEGs <- vector(mode = "list",length = 16)
names(Sex_DEGs) <- levels(Rn7_VTA$CellType)
for(i in names(Sex_DEGs)){
  Sex_DEGs[[i]] <- FindMarkers(object = Rn7_VTA,
                               ident.1 = paste0(i,"_Female"),
                               ident.2 = paste0(i,"_Male"))
}
### flatten list
Sex_DEGs <- do.call(what = rbind,Sex_DEGs)

## Create an ID column that is the rownames
Sex_DEGs$ID <- rownames(Sex_DEGs)

## Add gene names and cluster
Sex_DEGs <- separate(Sex_DEGs, col = ID, into = c("Cluster", "GeneName"), sep = "\\.", remove = FALSE, extra = "merge")

### subset for significant DEGs
Sex_DEGs.significant <- subset(Sex_DEGs,subset=(p_val_adj < 0.05))

## Build a table of the frequency by which the gene is differentially expressed by sex
Sex_DEGs_Freq <- as.data.frame(table(Sex_DEGs.significant$GeneName))

## Get chromosomes of all Sex_DEGs
for(i in 1:nrow(Sex_DEGs_Freq)){
  if(is.na(Rn7_gtf[which(Rn7_gtf$gene_name  %in% as.character(Sex_DEGs_Freq[i,"Var1"]))[1],"gene_name"]) == TRUE){
    Sex_DEGs_Freq[i,"Chr"] <- as.character(Rn7_gtf[which(Rn7_gtf$gene_id  %in% as.character(Sex_DEGs_Freq[i,"Var1"]))[1],
                                                   "seqnames"])
  }else{
    Sex_DEGs_Freq[i,"Chr"] <- Rn7_gtf[which(Rn7_gtf$gene_name  %in% as.character(Sex_DEGs_Freq[i,"Var1"]))[1],"seqnames"]
  }
}

## Get the mean fold change of the genes
Sex_DEGs_Freq$Mean_logFC <- NA
for(i in 1:nrow(Sex_DEGs_Freq)){
  if(Sex_DEGs_Freq[i,"Freq"]>1){
    Sex_DEGs_Freq[i,"Mean_logFC"] <- mean(subset(Sex_DEGs.significant,subset=(GeneName == as.character(Sex_DEGs_Freq[i,"Var1"])))$avg_log2FC)
  }else{
    Sex_DEGs_Freq[i,"Mean_logFC"] <- subset(Sex_DEGs.significant,subset=(GeneName == as.character(Sex_DEGs_Freq[i,"Var1"])))$avg_log2FC
  }
}

## Pull counts matrix
### First pull the count data
count_data_Full <- as.data.frame(t(as.matrix(GetAssayData(object = Rn7_VTA,slot = "data",assay = "RNA"))))
### check if rownames are in same order as the identities vector 
all(names(Idents(Rn7_VTA)) == rownames(count_data_Full)) #TRUE 
### Now just create a new column in the count_data_full for identity
count_data_Full$Identity <- as.factor(Rn7_VTA$Sex)
### Convert identitity to binary code. 
count_data_Full$Identity_bin <- ifelse(count_data_Full$Identity  == "Female",
                                       1, #Females are 1
                                       0) #Males are 0



## Create a subset of count data full containing all of the Sex_DEGs
count_data_subset <- count_data_Full[,c(as.character(Sex_DEGs_Freq$Var1),"Identity_bin")]





# Save outputs ####
write.csv(Sex_DEGs, file = "/path/to/sex_prediction_model/data/DEGs_sex_cluster_VTA_full.csv", row.names = F)
write.csv(Sex_DEGs.significant, file = "/path/to/sex_prediction_model/data/DEGs_sex_cluster_VTA_sig.csv", row.names = F)


write.table(x         = Sex_DEGs_Freq,
            file      = "/path/to/sex_prediction_model/data/DEGsbySexbyCluster_VTA.txt",
            sep       = "\t",
            col.names = TRUE,
            row.names = FALSE,
            quote     = FALSE)

saveRDS(object = count_data_subset,file = "/path/to/sex_prediction_model/data/count_data_subset_100423.RDS")

# Session info ####
sessionInfo()
```

```{bash filename="sex_differential_expresion_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=sex_diff
#SBATCH --output=/path/to/sex_prediction_model/logs/sex_differential_expression_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/sex_differential_expression_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=short
#SBATCH --time=6:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/sex_differential_expression.R
```


### Boruta
The Boruta feature selection algorithm further refined the set of significant DEGs by identifying genes with significant importance for cell sex classification within the VTA training partition. Importance was determined by iteratively comparing the importance, measured as Z-scores of mean decrease accuracy measure, of real genes to a set of null “shadow features” constructed from shuffled gene counts using the `Boruta()` function from the Boruta package (version 8.0.0). At each iteration, genes with significantly lower scores are rejected and removed while genes with significantly higher scores are confirmed and retained. After 2000 iterations, final decisions of genes with tentative importance were made using the `TentativeRoughFix()` Boruta function (see [Data Preparation](#data-preparation) section). The final set of genes with confirmed importance was used as predictive variables for cell sex classification models.

```{r filename="boruta_selection.R"}
# Setup ####
## libraries
library(Boruta)
## seed
set.seed(1234)
## load data
count_data_subset <- readRDS("/path/to/sex_prediction_model/data/count_data_subset_100423.RDS")

# Feature selection ####
VTA_Boruta <- Boruta(Identity_bin ~ ., data = count_data_subset, maxRuns = 2000, doTrace = 2)

# Save output ####
saveRDS(VTA_Boruta,"/path/to/sex_prediction_model/data/VTA_Boruta_max2000.RDS")

# Session info ####
sessionInfo()
```

```{bash filename="boruta_selection_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=boruta_selection
#SBATCH --output=/path/to/sex_prediction_model/logs/boruta_selection_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/boruta_selection_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=medium
#SBATCH --time=48:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/boruta_selection.R
```


### Data preparation
Before training our models we need to extract the relevant feature data from our data partitions and format it in such a way that is easy for our models to parse.

```{r filename="prepare_model_data.R"}
# Setup ####
## libraries
library(Seurat)
library(Boruta)
library(dplyr)

## set seed
set.seed(1234)

## load data
### Boruta object
VTA_Boruta_max2000 <- readRDS("/path/to/sex_prediction_model/data/VTA_Boruta_max2000.RDS")
### training data
Rn7_VTA_training <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA_training.RDS")
### training data count matrix of sex DEGs
training_count_data_sex <- readRDS("/path/to/sex_prediction_model/data/count_data_subset_100423.RDS")
### testing data
Rn7_VTA_testing <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA_testing.RDS")

# Select important features ####
## Boruta information extraction
### TentativeRoughFix for tentative features
### Boruta ran for 1.377593 days completed its maximum number of iterations, but left 16 attributes tentative features tentative.
### we'll run `TentativeRoughFix()` to make decisions about the remaining features
VTA_Boruta <- TentativeRoughFix(VTA_Boruta_max2000)

### extract decisions for features
VTA_Boruta_decision <- VTA_Boruta$finalDecision %>% data.frame()
colnames(VTA_Boruta_decision) <- c("finalDecision")
VTA_Boruta_decision$variable <- rownames(VTA_Boruta_decision)
VTA_Boruta_decision <- VTA_Boruta_decision %>% select(variable, finalDecision) # reorder for my sanity

### Get the column names with confirmed values
confirmed_columns <- VTA_Boruta_decision$variable[VTA_Boruta_decision$finalDecision == "Confirmed"]


# Create count data subsets ####
## For training and testing data sets, we'll use dataframes of only confirmed important predictors and the outcome identity column

## Create training count data subsets
training_count_data_sex_important <- training_count_data_sex[, colnames(training_count_data_sex) %in% confirmed_columns]
### Add identity bin back in
training_count_data_sex_important$Identity_bin <- training_count_data_sex$Identity_bin

## Create testing count data subset
count_data <- as.data.frame(t(as.matrix(GetAssayData(object = Rn7_VTA_testing,slot = "data",assay = "RNA"))))
### check if rownames are in same order as the identities vector 
all(names(Idents(Rn7_VTA_testing)) == rownames(count_data)) #TRUE 
### Now just create a new column in the count_data_full for identity
count_data$Identity <- as.factor(Rn7_VTA_testing$Sex)
### Convert identitity to binary code. 
count_data$Identity_bin <- ifelse(count_data$Identity  == "Female",
                                  1, #Females are 1
                                  0) #Males are 0
### Create a subset of count data containing the same features as the training set
test_count_data_sex_important <- count_data[,colnames(count_data) %in% colnames(training_count_data_sex_important)]

# Save outputs ####
## Boruta variable final decisions
write.csv(VTA_Boruta_decision, file = "/path/to/sex_prediction_model/data/Boruta_final_decisions.csv", row.names = F)
## training and testing count data frames
write.csv(training_count_data_sex_important, file = "/path/to/sex_prediction_model/data/training_count_data.csv")
write.csv(test_count_data_sex_important, file = "/path/to/sex_prediction_model/data/test_count_data.csv")


# Session Info
sessionInfo()
```

```{bash filename="prepare_model_data_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=prepare_model_data
#SBATCH --output=/path/to/sex_prediction_model/logs/prepare_model_data_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/prepare_model_data_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/prepare_model_data.R
```


#### Plotting: feature selection 
To get an idea of how our feature selection results look, we make a few plots that capture the important parts of our selection process.

First, we plot a heatmap of our sex dependent DEGs' log2 fold changes across clusters. Log2 fold changes are calculated by seurat as the average expression in females +1 divided by the average expression in males +1. The pseudocount of 1 is added to avoid dividing by and taking the log of zero. Plotting this gives us an idea of the magnitude of changes and how these are reflected across cell types. A number of genes are only significant and/or tested in a subset of cell types, for genes not tested, we can calculate their fold change values again using the seurat `FindMarkers()` function.

We'll also plot the results of our feature selection using Boruta. For each of the 2000 iterations run, Boruta ascertains the importance of each feature and shadow feature to determine their final decision as important or not. Boruta has a built in plot functionality that generates boxplots for the distribution of  each gene's importance results across all iterations, and orders these boxplots by their median importance. Here we implement a similar plotting strategy using ggplot for easier customization. Plotting this gives us a quick and easy way to view the proportions of "confirmed" and "rejected" genes, as well as their trends in importance.

```{r filename="feature_selection_plot.R"}
# Setup ####
## libraries
library(Seurat)
library(Boruta)
library(dplyr)
library(tidyr)
library(ggplot2)
library(plotly)
library(forcats)


## seed
set.seed(1234)

## data
### Training object
training.obj <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA_training.RDS") 
### Testing object
testing.obj <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA_testing.RDS")

### DEGs
#### full results set
degs.full <- read.csv("/path/to/sex_prediction_model/data/DEGs_sex_cluster_VTA_full.csv") %>% 
  mutate(Cluster= factor(Cluster, levels = c("DA-Neuron","Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3",
                                                "Olig-1", "Olig-2", "Olig-3", "Astrocyte","Microglia","Polydendrocyte","OPC-Olig-1", "Mural", "Endothelial")))
#### significant results set
degs.sig <- degs.full %>% filter(p_val_adj < 0.05)
#### significant gene names
degs.sig.genes <- degs.sig %>% 
  pull(GeneName) %>% 
  unique()
#### names of clusters
degs.sig.cluster <- degs.sig %>% 
  pull(Cluster) %>% 
  unique()
### Boruta objet
boruta.obj <- readRDS("/path/to/sex_prediction_model/data/VTA_Boruta_max2000.RDS")
boruta.obj.fix <- TentativeRoughFix(boruta.obj)
#### genes
selected.genes <- read.csv("/path/to/sex_prediction_model/data/Boruta_final_decisions.csv") %>% 
  filter(finalDecision == "Confirmed") %>% 
  pull("variable")



# DEGs ####
## fill in lfc values for significant genes, across clusters
### calculate lfc values (note: there is a known issue in Seurat 4.3.0.1 where `FoldChange()` does not return consistent results with `FindMarkers()`. `FindMarkers()` values are correct.)
Idents(training.obj) <- training.obj$CellType_Sex

#### initialize results list
lfc.df <- vector(mode = "list",length = 16)
names(lfc.df) <- levels(training.obj$CellType)
for(i in names(lfc.df)){
  lfc.df[[i]] <- FindMarkers(object = training.obj,
                               ident.1 = paste0(i,"_Female"),
                               ident.2 = paste0(i,"_Male"),
                               logfc.threshold = 0,
                               min.pct = 0,
                               min.cells.group = 0)
}
#### flatten list
lfc.df <- do.call(what = rbind,lfc.df)

#### Create an ID column that is the rownames
lfc.df$ID <- rownames(lfc.df)

#### Add gene names and cluster
lfc.df <- separate(lfc.df, col = ID, into = c("Cluster", "GeneName"), sep = "\\.", remove = FALSE, extra = "merge")
#### filter for significant results
lfc.df <- lfc.df %>% 
  filter(GeneName %in% degs.sig.genes)

### make complete df
deg.df.full <- expand.grid(Cluster = levels(degs.sig.cluster),
                           GeneName = degs.sig.genes)
deg.df.full <- left_join(x = deg.df.full,
                         y = degs.sig %>% select(Cluster, GeneName, avg_log2FC),
                         by = c("Cluster", "GeneName"),
                         keep = F,
                         relationship = "one-to-one")
deg.df.full <- left_join(deg.df.full,
                         y = lfc.df %>% select(Cluster, GeneName, avg_log2FC),
                         by = c("Cluster", "GeneName"),
                         keep = F,
                         relationship = "one-to-one")

deg.df.full.coalesce <- deg.df.full %>% 
  mutate(avg_log2FC = coalesce(avg_log2FC.x, avg_log2FC.y)) %>% 
  select(Cluster, GeneName, avg_log2FC) %>% 
  mutate(Cluster= factor(Cluster, levels = c("DA-Neuron","Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3",
                                             "Olig-1", "Olig-2", "Olig-3", "Astrocyte","Microglia","Polydendrocyte","OPC-Olig-1", "Mural", "Endothelial") %>% rev()))

## plot heatmap
degs.plot.hm <- ggplot(deg.df.full.coalesce , aes(x = Cluster, y = fct_reorder(GeneName, avg_log2FC, mean), fill = avg_log2FC)) +
  geom_tile() +
  scale_fill_gradient2(
    low = "#00BFC4",
    mid = "white",
    high = "#F8766D",
    midpoint = 0,
    limits = c(-2.5,2.5),
    oob = scales::squish) +
  labs(x = "Cell Type", y = "Gene", fill = "Log2 FC") +
  coord_flip() +
  theme(axis.text.x = element_blank(),
        panel.background = element_blank())
### interactive version
degs.plotly <- ggplotly(degs.plot.hm)

# Boruta ####
#ggplotting code from https://stackoverflow.com/questions/73415232/how-to-use-ggplot2-to-plot-box-plots-from-borutas-results-in-r
## object manipulation
### create list of importance histories for each gene
lz <- lapply(1:ncol(boruta.obj.fix$ImpHistory),
             function(i) boruta.obj.fix$ImpHistory[is.finite(boruta.obj.fix$ImpHistory[,i]),i])
### set names for each gene list
names(lz) <- colnames(boruta.obj.fix$ImpHistory) 
### set order for list items to be decreasing by median importance
ii <- order(sapply(lz,stats::median))
lz[ii] -> lz
### collapse to data frame
lz_df <- do.call(rbind.data.frame, lz)
df <- as.data.frame(t(lz_df))
names(df) <- names(lz)
rownames(df) <- NULL
### make vector of colors
generateCol<-function(x,colCode,col,numShadow){
  #Checking arguments
  if(is.null(col) & length(colCode)!=4)
    stop('colCode should have 4 elements.')
  #Generating col
  if(is.null(col)){
    rep(colCode[4],length(x$finalDecision)+numShadow)->cc
    cc[c(x$finalDecision=='Confirmed',rep(FALSE,numShadow))]<-colCode[1]
    cc[c(x$finalDecision=='Tentative',rep(FALSE,numShadow))]<-colCode[2]
    cc[c(x$finalDecision=='Rejected',rep(FALSE,numShadow))]<-colCode[3]
    col=cc
  }
  return(col)
}
boruta.col <- generateCol(boruta.obj.fix, c('confirmed','tentative','rejected','shadow'), NULL, 3)
boruta.col <- boruta.col[ii]
color.match <- data.frame(name = names(lz),
                          color = factor(boruta.col, levels = c("confirmed", "rejected", "tentative", "shadow")))

df.long <- df %>% 
  pivot_longer(everything()) %>% 
  mutate(name = factor(name, levels = names(df)))

df.long <- left_join(df.long,
                          color.match,
                          by = "name",
                          keep = F,
                          relationship = "many-to-one")

# gene.highlights <- c("shadowMin", "shadowMean", "shadowMax")

boruta.plot <- ggplot(df.long, aes(x = fct_reorder(name, value, median), y = value)) +
  geom_boxplot(mapping = aes(col = color), fill = "white",
               outlier.alpha = 0.5,
               outlier.size = 0.5,
               outlier.shape = NA) +
  # scale_x_discrete(breaks = gene.highlights,
  #                  labels = c("Shadow Min", "Shadow Mean", "Shadow Max")) +
  scale_color_manual(values = c("shadow" = "blue", "confirmed" = "green", "rejected" = "red", "tentative" = "yellow")) +
  labs(x = "Gene", y = "Importance", color = "Decision") +
  theme_bw() + 
  theme(legend.position = c(0.15,0.85),
        panel.grid = element_blank(),
        panel.background = element_blank(),
        axis.text.x = element_blank(),
        text = element_text(size = 15))

## plot example genes
Idents(training.obj) <- training.obj$CellType

genes.vln <- VlnPlot(training.obj,
                     features = c("ENSRNOG00000060617", # Uty, most important male biased gene
                                  "Ddx3",               # second most important male biased gene
                                  "ENSRNOG00000065796", # Xist, most important female biased gene
                                  "Kdm6a",              # second most important female biased gene
                                  "Fam210a",            # two least important genes
                                  "Trabd2b"),
                     split.by = "Sex",
                     cols = c("#F8766D", "#00BFC4"),
                     flip = T, stack = T) + theme(legend.position = "top")


# Gene distributions ####
# Pre-process data
## training
### make neuronal and non-neuronal metadata
training.obj@meta.data <- training.obj@meta.data %>%
  mutate(Neuronal = case_when(CellType %in% c("Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3", "DA-Neuron") ~ "Neuronal",
                              CellType %in% c("Olig-1", "Olig-2", "Olig-3", "Astrocyte", "Polydendrocyte", "Microglia", "OPC-Olig-1", "Mural", "Endothelial") ~ "Non-neuronal"))
training.obj@meta.data <- training.obj@meta.data %>% 
  mutate(Neuronal = factor(Neuronal, levels = c("Neuronal", "Non-neuronal")))
### extract count matrix
training.count.data <- as.data.frame(t(as.matrix(GetAssayData(object = training.obj,slot = "data",assay = "RNA")))) %>% 
  select(all_of(selected.genes))
### create cell lists for neuronal and non-neuronal cells
training.neuronal.cells <- training.obj@meta.data %>% filter(Neuronal == "Neuronal") %>% rownames()
training.nonneuronal.cells <- training.obj@meta.data %>% filter(Neuronal != "Neuronal") %>% rownames()
### create count dfs for neuronal and non-neuronal cells
training.count.data.neurons <- training.count.data[training.neuronal.cells,] 
training.count.data.nonneurons <- training.count.data[training.nonneuronal.cells,]
### nFeatures
training.nfeature.neurons <- data.frame(cell = row.names(training.count.data.neurons),
                                        cell.type = rep("Neuronal", nrow(training.count.data.neurons)),
                                        nFeature = rowSums(training.count.data.neurons != 0))
training.nfeature.nonneurons <- data.frame(cell = row.names(training.count.data.nonneurons),
                                           cell.type = rep("Non-neuronal", nrow(training.count.data.nonneurons)),
                                           nFeature = rowSums(training.count.data.nonneurons != 0))
training.nfeature <- rbind(training.nfeature.neurons,training.nfeature.nonneurons)


training.gene.distb <- ggplot(training.nfeature, aes(x = nFeature, fill = cell.type)) +
  geom_density(alpha = 0.7) +
  scale_fill_manual(values = c("Neuronal" = "#624185", "Non-neuronal" = "#ffa345")) +
  labs(x = "Number of genes", y = "Density") +
  theme_bw() +
  theme(panel.grid = element_blank(),
        legend.position = c(0.1,0.9),
        legend.title= element_blank(),
        text = element_text(size = 15))

## testing
### make neuronal and non-neuronal metadata
testing.obj@meta.data <- testing.obj@meta.data %>%
  mutate(Neuronal = case_when(CellType %in% c("Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3", "DA-Neuron") ~ "Neuronal",
                              CellType %in% c("Olig-1", "Olig-2", "Olig-3", "Astrocyte", "Polydendrocyte", "Microglia", "OPC-Olig-1", "Mural", "Endothelial") ~ "Non-neuronal"))
testing.obj@meta.data <- testing.obj@meta.data %>% 
  mutate(Neuronal = factor(Neuronal, levels = c("Neuronal", "Non-neuronal")))
### extract count matrix
testing.count.data <- as.data.frame(t(as.matrix(GetAssayData(object = testing.obj,slot = "data",assay = "RNA")))) %>% 
  select(all_of(selected.genes))
### create cell lists for neuronal and non-neuronal cells
testing.neuronal.cells <- testing.obj@meta.data %>% filter(Neuronal == "Neuronal") %>% rownames()
testing.nonneuronal.cells <- testing.obj@meta.data %>% filter(Neuronal != "Neuronal") %>% rownames()
### create count dfs for neuronal and non-neuronal cells
testing.count.data.neurons <- testing.count.data[testing.neuronal.cells,] 
testing.count.data.nonneurons <- testing.count.data[testing.nonneuronal.cells,] 
### nFeatures
testing.nfeature.neurons <- data.frame(cell = row.names(testing.count.data.neurons),
                                       cell.type = rep("Neuronal", nrow(testing.count.data.neurons)),
                                       nFeature = rowSums(testing.count.data.neurons != 0))
testing.nfeature.nonneurons <- data.frame(cell = row.names(testing.count.data.nonneurons),
                                          cell.type = rep("Non-neuronal", nrow(testing.count.data.nonneurons)),
                                          nFeature = rowSums(testing.count.data.nonneurons != 0))
testing.nfeature <- rbind(testing.nfeature.neurons,testing.nfeature.nonneurons)


testing.gene.distb <- ggplot(testing.nfeature, aes(x = nFeature, fill = cell.type)) +
  geom_density(alpha = 0.7) +
  scale_fill_manual(values = c("Neuronal" = "#624185", "Non-neuronal" = "#ffa345")) +
  labs(x = "Number of genes", y = "Density") +
  theme_bw() +
  theme(panel.grid = element_blank(),
        legend.position = c(0.1,0.9),
        legend.title= element_blank(),
        text = element_text(size = 15))

# Save outputs ####
## DEGs
ggsave(plot = degs.plot.hm,
       filename = "/path/to/sex_prediction_model/output/feature_selection/deg.sig.heatmap.pdf",
       height = 5,
       width = 10,
       units = "in",
       device = "pdf")
htmlwidgets::saveWidget(as_widget(degs.plotly), "/path/to/sex_prediction_model/output/feature_selection/deg.sig.heatmap.html")
write.csv(lfc.df,
          file = "/path/to/sex_prediction_model/output/feature_selection/unfiltered_deg_results.csv",
          row.names = F)
write.csv(deg.df.full.coalesce,
          file = "/path/to/sex_prediction_model/output/feature_selection/lfc_sig_allclusters.csv", 
          row.names = F)

## Boruta
ggsave(plot = boruta.plot,
       filename = "/path/to/sex_prediction_model/output/feature_selection/boruta.decisions.pdf",
       height = 5,
       width = 10,
       units = "in",
       device = "pdf")

ggsave(plot = genes.vln,
       filename = "/path/to/sex_prediction_model/output/feature_selection/example_gene_vln.pdf",
       height = 11,
       width = 7,
       units = "in",
       device = "pdf")

## model gene expression
ggsave(plot = training.gene.distb,
       filename = "/path/to/sex_prediction_model/output/feature_selection/training.model.nFeature.distb.pdf",
       height = 10,
       width = 10)

ggsave(plot = testing.gene.distb,
       filename = "/path/to/sex_prediction_model/output/feature_selection/testing.model.nFeature.distb.pdf",
       height = 10,
       width = 10)

# SessionInfo ####
sessionInfo()
```

```{bash filename="feature_selection_plot_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=feature_selection_plot
#SBATCH --output=/path/to/sex_prediction_model/logs/feature_selection_plot_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/feature_selection_plot_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/feature_selection_plot.R
```


#### Ploting: gene expression
This section contains additional exploratory visualization of genes with sex dependent expression. 

```{r filename="geneexpression.R"}
# Setup ####
## libraries
library(Seurat)
library(dplyr)
library(ggplot2)
library(tibble)
library(tidyr)

## set seed
set.seed(1234)

## functions
### count Y transcripts
y.count <- function(srat.object){
  # load gene expression count data
  srat.counts <- as.data.frame(t(as.matrix(GetAssayData(object = srat.object, slot = "data", assay = "RNA"))))
  
  # load gene annotations
  Rn7.gtf <- rtracklayer::import("/path/to/sex_prediction_model/data/Rattus_norvegicus.mRatBN7.2.105.gtf")
  Rn7.gtf <- as.data.frame(Rn7.gtf)
  
  # select Y chromosome genes
  y.genes <- Rn7.gtf %>% #from Rn7 gene annotations
    filter(seqnames == "Y") %>% #filter for chrY only
    select(gene_id, gene_name) %>% #select gene ids and names
    mutate(gene_name = coalesce(gene_name, gene_id)) %>% #replace NA name values with gene ID
    pull(gene_name) %>% #pull gene name values
    unique() #only unique values, returns 27 genes
  
  # create cumulative expresion of Y genes
  y.counts <- srat.counts %>%
    select(any_of(y.genes)) %>%
    rowSums() %>% data.frame()
  ### set column name
  colnames(y.counts) <- c("y.counts")
  
  return(y.counts)
}
### count Xist transcripts
Xist.count <- function(srat.object){
  # load gene expression count data
  Xist.counts <- as.data.frame(t(as.matrix(GetAssayData(object = srat.object, slot = "data", assay = "RNA")))) %>%
    pull("ENSRNOG00000065796") # pull out Xist (named as ENSRNOG00000065796)
  
  return(Xist.counts)
}

## data
### VTA object
Rn7_VTA <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA.RDS")
#### training object
Rn7_VTA.training <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA_training.RDS")
#### testing object
Rn7_VTA.testing <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA_testing.RDS")

## genes
### Rn7 gene annotations
Rn7.gtf <- rtracklayer::import("/path/to/sex_prediction_model/data/Rattus_norvegicus.mRatBN7.2.105.gtf")
Rn7.gtf <- as.data.frame(Rn7.gtf)
### selected genes
selected.genes <- read.csv("/path/to/sex_prediction_model/data/Boruta_final_decisions.csv") %>% 
  filter(finalDecision == "Confirmed") %>% 
  pull("variable")
### Y chromosome genes
y.genes <- Rn7.gtf %>% #from Rn7 gene annotations
  filter(seqnames == "Y") %>% #filter for chrY only
  select(gene_id, gene_name) %>% #select gene ids and names
  mutate(gene_name = coalesce(gene_name, gene_id)) %>% #replace NA name values with gene ID
  pull(gene_name) %>% #pull gene name values
  unique() #only unique values, returns 27 genes


# Pre-processing data ####
## count Y genes
Rn7_VTA$y.counts <- y.count(Rn7_VTA) # whole object
Rn7_VTA.training$y.counts <- y.count(Rn7_VTA.training) # training object
Rn7_VTA.testing$y.counts <- y.count(Rn7_VTA.testing) # testing object
## count X genes
Rn7_VTA$Xist.counts <- Xist.count(Rn7_VTA)
Rn7_VTA.training$Xist.counts <- Xist.count(Rn7_VTA.training)
Rn7_VTA.testing$Xist.counts <- Xist.count(Rn7_VTA.testing)

## Make neuronal/non-neuronal cell type column
Rn7_VTA@meta.data <- Rn7_VTA@meta.data %>%
  mutate(Neuronal = case_when(CellType %in% c("Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3", "DA-Neuron") ~ "Neuronal",
                              CellType %in% c("Olig-1", "Olig-2", "Olig-3", "Astrocyte", "Polydendrocyte", "Microglia", "OPC-Olig-1", "Mural", "Endothelial") ~ "Non-neuronal")) # make a new column to designate neuronal and non-neuronal
Rn7_VTA@meta.data <- Rn7_VTA@meta.data %>% 
  mutate(Neuronal = factor(Neuronal, levels = c("Neuronal", "Non-neuronal")),
         CellType = factor(CellType, levels = c("DA-Neuron","Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3",
                                                "Olig-1", "Olig-2", "Olig-3", "Astrocyte","Microglia","Polydendrocyte","OPC-Olig-1", "Mural", "Endothelial"))) # make cell type and neuronal/non-neuronal factors 

Rn7_VTA.training@meta.data <- Rn7_VTA.training@meta.data %>%
  mutate(Neuronal = case_when(CellType %in% c("Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3", "DA-Neuron") ~ "Neuronal",
                              CellType %in% c("Olig-1", "Olig-2", "Olig-3", "Astrocyte", "Polydendrocyte", "Microglia", "OPC-Olig-1", "Mural", "Endothelial") ~ "Non-neuronal")) # make a new column to designate neuronal and non-neuronal
Rn7_VTA.training@meta.data <- Rn7_VTA.training@meta.data %>% 
  mutate(Neuronal = factor(Neuronal, levels = c("Neuronal", "Non-neuronal")),
         CellType = factor(CellType, levels = c("DA-Neuron","Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3",
                                                "Olig-1", "Olig-2", "Olig-3", "Astrocyte","Microglia","Polydendrocyte","OPC-Olig-1", "Mural", "Endothelial"))) # make cell type and neuronal/non-neuronal factors 

Rn7_VTA.testing@meta.data <- Rn7_VTA.testing@meta.data %>%
  mutate(Neuronal = case_when(CellType %in% c("Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3", "DA-Neuron") ~ "Neuronal",
                              CellType %in% c("Olig-1", "Olig-2", "Olig-3", "Astrocyte", "Polydendrocyte", "Microglia", "OPC-Olig-1", "Mural", "Endothelial") ~ "Non-neuronal")) # make a new column to designate neuronal and non-neuronal
Rn7_VTA.testing@meta.data <- Rn7_VTA.testing@meta.data %>% 
  mutate(Neuronal = factor(Neuronal, levels = c("Neuronal", "Non-neuronal")),
         CellType = factor(CellType, levels = c("DA-Neuron","Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3",
                                                "Olig-1", "Olig-2", "Olig-3", "Astrocyte","Microglia","Polydendrocyte","OPC-Olig-1", "Mural", "Endothelial"))) # make cell type and neuronal/non-neuronal factors 

## Sex distributions
### all cells
all.sex.distb.df.long <- table(Rn7_VTA$CellType, Rn7_VTA$Sex) %>% # make a table of cell counts per cell type by sex
  as.data.frame.matrix() %>% # convert to dataframe
  rownames_to_column("CellType") %>% # make cell type a column
  mutate(CellType = factor(CellType, levels = c("DA-Neuron","Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3",
                                                "Olig-1", "Olig-2", "Olig-3", "Astrocyte","Microglia","Polydendrocyte","OPC-Olig-1", "Mural", "Endothelial"))) %>% # make cell type a factor
  pivot_longer(cols = Female:Male, names_to = "Sex", values_to = "count") # pivot longer for plotting
### training cells
training.sex.distb.df.long <- table(Rn7_VTA.training$CellType, Rn7_VTA.training$Sex) %>% # make a table of cell counts per cell type by sex
  as.data.frame.matrix() %>% # convert to dataframe
  rownames_to_column("CellType") %>% # make cell type a column
  mutate(CellType = factor(CellType, levels = c("DA-Neuron","Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3",
                                                "Olig-1", "Olig-2", "Olig-3", "Astrocyte","Microglia","Polydendrocyte","OPC-Olig-1", "Mural", "Endothelial"))) %>% # make cell type a factor
  pivot_longer(cols = Female:Male, names_to = "Sex", values_to = "count") # pivot longer for plotting
### testing cells
testing.sex.distb.df.long <- table(Rn7_VTA.testing$CellType, Rn7_VTA.testing$Sex) %>% # make a table of cell counts per cell type by sex
  as.data.frame.matrix() %>% # convert to dataframe
  rownames_to_column("CellType") %>% # make cell type a column
  mutate(CellType = factor(CellType, levels = c("DA-Neuron","Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3",
                                                "Olig-1", "Olig-2", "Olig-3", "Astrocyte","Microglia","Polydendrocyte","OPC-Olig-1", "Mural", "Endothelial"))) %>% # make cell type a factor
  pivot_longer(cols = Female:Male, names_to = "Sex", values_to = "count") # pivot longer for plotting

## ncells per cluster
### all cells
all.ncells.df <- table(Rn7_VTA$CellType) %>% # make a table of cell type counts
  data.frame() %>% # convert to dataframe
  rename("CellType" = "Var1",
         "Cells" = "Freq") %>% # rename columns
  mutate(CellType = factor(CellType, levels = c("DA-Neuron","Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3",
                                                "Olig-1", "Olig-2", "Olig-3", "Astrocyte","Microglia","Polydendrocyte","OPC-Olig-1", "Mural", "Endothelial"))) # make cell type a factor
### training cells
training.ncells.df <- table(Rn7_VTA.training$CellType) %>% # make a table of cell type counts
  data.frame() %>% # convert to dataframe
  rename("CellType" = "Var1",
         "Cells" = "Freq") %>% # rename columns
  mutate(CellType = factor(CellType, levels = c("DA-Neuron","Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3",
                                                "Olig-1", "Olig-2", "Olig-3", "Astrocyte","Microglia","Polydendrocyte","OPC-Olig-1", "Mural", "Endothelial"))) # make cell type a factor
### testing cells
testing.ncells.df <- table(Rn7_VTA.testing$CellType) %>% # make a table of cell type counts
  data.frame() %>% # convert to dataframe
  rename("CellType" = "Var1",
         "Cells" = "Freq") %>% # rename columns
  mutate(CellType = factor(CellType, levels = c("DA-Neuron","Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3",
                                                "Olig-1", "Olig-2", "Olig-3", "Astrocyte","Microglia","Polydendrocyte","OPC-Olig-1", "Mural", "Endothelial"))) # make cell type a factor


# Plots ####
## whole object
### clustering
#### UMAP
Rn7_VTA@active.ident <- Rn7_VTA$CellType
all.dimplot.clusters <- DimPlot(Rn7_VTA)
#### Number of cells per cluster
all.ncells.clusters <- ggplot(data = all.ncells.df, mapping = aes(x = CellType, y = Cells, fill = CellType)) +
  geom_bar(stat = "identity") +
  scale_y_log10() +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        text = element_text(size = 15),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 15),
        panel.grid = element_blank()) +
  NoLegend()

### distribution of sexes
#### UMAP
Rn7_VTA@active.ident <- factor(Rn7_VTA$Sex, levels = c("Female", "Male")) # set active identity to sex for this plot
all.dimplot.sexes <- DimPlot(Rn7_VTA, shuffle = T)
#### proportions per cluster
all.prop.sexes <- ggplot(data = all.sex.distb.df.long, mapping = aes(x = CellType, y = count, fill = Sex)) +
  geom_bar(position="fill", stat="identity") +
  labs(x = "Cell Type", y = "Proportion") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        text = element_text(size = 15),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 15),
        panel.grid = element_blank()) +
  NoLegend()

Rn7_VTA@active.ident <- Rn7_VTA$CellType # set active identity back to cell type

### Y gene counts
#### feature plot
all.dim.plot.y <- FeaturePlot(Rn7_VTA,
                              features = "y.counts",
                              split.by = "Sex",
                              cols = c("lightgrey","blue"),
                              keep.scale = "all")
#### violin
all.vln.plot.y <- VlnPlot(Rn7_VTA,
                          features = "y.counts",
                          split.by = "Sex",
                          pt.size = 0) +
  labs(x = "Cell Type", y = "ChrY Gene Expression") +
  NoLegend()

### Xist
#### feature plot
all.dim.plot.xist <- FeaturePlot(Rn7_VTA,
                                 features = "Xist.counts",
                                 split.by = "Sex",
                                 cols = c("lightgrey","red"),
                                 keep.scale = "all") 

#### violin
all.vln.plot.xist <- VlnPlot(Rn7_VTA,
                             features = "Xist.counts",
                             split.by = "Sex",
                             pt.size = 0) +
  labs(x = "Cell Type", y = "Xist Gene Expression") +
  NoLegend()

### DEGs
all.vln.plot.degs <- VlnPlot(Rn7_VTA,
                             features = c("ENSRNOG00000060617",
                                          "ENSRNOG00000065796",
                                          "Kdm5d",
                                          "Eif2s3y",
                                          "Kdm6a",
                                          "Cntnap2",
                                          "Crip1"),
                             split.by = "Sex",
                             pt.size = 0,
                             stack = T,
                             flip = T) +
  labs(x = "Cell Type") +
  theme(legend.position = "top")

### gene counts
#### distribution
all.gene.count.distb <- ggplot(data = Rn7_VTA@meta.data, mapping = aes(x = nFeature_RNA, fill = Neuronal)) +
  geom_density(alpha = 0.7) +
  labs(x = "Number of Genes", y = "Density") +
  theme_bw() +
  theme(text = element_text(size = 15),
        axis.text = element_text(size = 10),
        legend.position = c(0.9, 0.9),
        legend.title= element_blank()) +
  NoGrid()


## training object
### clustering
#### UMAP
Rn7_VTA.training@active.ident <- Rn7_VTA.training$CellType
training.dimplot.clusters <- DimPlot(Rn7_VTA.training)
#### Number of cells per cluster
training.ncells.clusters <- ggplot(data = training.ncells.df, mapping = aes(x = CellType, y = Cells, fill = CellType)) +
  geom_bar(stat = "identity") +
  scale_y_log10() +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        text = element_text(size = 15),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 15),
        panel.grid = element_blank()) +
  NoLegend()

### distribution of sexes
#### UMAP
Rn7_VTA.training@active.ident <- factor(Rn7_VTA.training$Sex, levels = c("Female", "Male")) # set active ident to sex for this plot
training.dimplot.sexes <- DimPlot(Rn7_VTA.training)
#### proportions per cluster
training.prop.sexes <- ggplot(data = training.sex.distb.df.long, mapping = aes(x = CellType, y = count, fill = Sex)) +
  geom_bar(position="fill", stat="identity") +
  labs(x = "Cell Type", y = "Proportion") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        text = element_text(size = 15),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 15),
        panel.grid = element_blank()) +
  NoLegend()

Rn7_VTA.training@active.ident <- Rn7_VTA.training$CellType # reset active ident to cell type

### Y gene counts
#### feature plot
training.dim.plot.y <- FeaturePlot(Rn7_VTA.training,
                                   features = "y.counts",
                                   split.by = "Sex",
                                   cols = c("lightgrey","blue"),
                                   keep.scale = "all")
#### violin
training.vln.plot.y <- VlnPlot(Rn7_VTA.training,
                               features = "y.counts",
                               split.by = "Sex",
                               pt.size = 0) +
  labs(x = "Cell Type", y = "ChrY Gene Expression") +
  NoLegend()

### Xist
#### feature plot
training.dim.plot.xist <- FeaturePlot(Rn7_VTA.training,
                                      features = "Xist.counts",
                                      split.by = "Sex",
                                      cols = c("lightgrey","red"),
                                      keep.scale = "all") 

#### violin
training.vln.plot.xist <- VlnPlot(Rn7_VTA.training,
                                  features = "Xist.counts",
                                  split.by = "Sex",
                                  pt.size = 0) +
  labs(x = "Cell Type", y = "Xist Gene Expression") +
  NoLegend()

### DEGs
training.vln.plot.degs <- VlnPlot(Rn7_VTA.training,
                                  features = c("ENSRNOG00000060617",
                                               "ENSRNOG00000065796",
                                               "Kdm5d",
                                               "Eif2s3y",
                                               "Kdm6a",
                                               "Cntnap2",
                                               "Crip1"),
                                  split.by = "Sex",
                                  pt.size = 0,
                                  stack = T,
                                  flip = T) +
  labs(x = "Cell Type") +
  theme(legend.position = "top")


### gene counts
#### distribution
training.gene.count.distb <- ggplot(data = Rn7_VTA.training@meta.data, mapping = aes(x = nFeature_RNA, fill = Neuronal)) +
  geom_density(alpha = 0.7) +
  labs(x = "Number of Genes", y = "Density") +
  theme_bw() +
  theme(text = element_text(size = 15),
        axis.text = element_text(size = 10),
        legend.position = c(0.9, 0.9),
        legend.title= element_blank()) +
  NoGrid()

## testing object
### clustering
#### UMAP
Rn7_VTA.testing@active.ident <- Rn7_VTA.testing$CellType
testing.dimplot.clusters <- DimPlot(Rn7_VTA.testing)
#### Number of cells per cluster
testing.ncells.clusters <- ggplot(data = testing.ncells.df, mapping = aes(x = CellType, y = Cells, fill = CellType)) +
  geom_bar(stat = "identity") +
  scale_y_log10() +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        text = element_text(size = 15),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 15),
        panel.grid = element_blank()) +
  NoLegend()

### distribution of sexes
#### UMAP
Rn7_VTA.testing@active.ident <- factor(Rn7_VTA.testing$Sex, levels = c("Female", "Male")) # set active ident to sex for this plot
testing.dimplot.sexes <- DimPlot(Rn7_VTA.testing)
#### proportions per cluster
testing.prop.sexes <- ggplot(data = testing.sex.distb.df.long, mapping = aes(x = CellType, y = count, fill = Sex)) +
  geom_bar(position="fill", stat="identity") +
  labs(x = "Cell Type", y = "Proportion") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        text = element_text(size = 15),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 15),
        panel.grid = element_blank()) +
  NoLegend()

Rn7_VTA.testing@active.ident <- Rn7_VTA.testing$CellType # reset active ident to cell type

### Y gene counts
#### feature plot
testing.dim.plot.y <- FeaturePlot(Rn7_VTA.testing,
                                  features = "y.counts",
                                  split.by = "Sex",
                                  cols = c("lightgrey","blue"),
                                  keep.scale = "all")
#### violin
testing.vln.plot.y <- VlnPlot(Rn7_VTA.testing,
                              features = "y.counts",
                              split.by = "Sex",
                              pt.size = 0) +
  labs(x = "Cell Type", y = "ChrY Gene Expression") +
  NoLegend()

### Xist
#### feature plot
testing.dim.plot.xist <- FeaturePlot(Rn7_VTA.testing,
                                     features = "Xist.counts",
                                     split.by = "Sex",
                                     cols = c("lightgrey","red"),
                                     keep.scale = "all") 

#### violin
testing.vln.plot.xist <- VlnPlot(Rn7_VTA.testing,
                                 features = "Xist.counts",
                                 split.by = "Sex",
                                 pt.size = 0) +
  labs(x = "Cell Type", y = "Xist Gene Expression") +
  NoLegend()

### DEGs
testing.vln.plot.degs <- VlnPlot(Rn7_VTA.testing,
                                 features = c("ENSRNOG00000060617",
                                              "ENSRNOG00000065796",
                                              "Kdm5d",
                                              "Eif2s3y",
                                              "Kdm6a",
                                              "Cntnap2",
                                              "Crip1"),
                                 split.by = "Sex",
                                 pt.size = 0,
                                 stack = T,
                                 flip = T) +
  labs(x = "Cell Type") +
  theme(legend.position = "top")


### gene counts
#### distribution
testing.gene.count.distb <- ggplot(data = Rn7_VTA.testing@meta.data, mapping = aes(x = nFeature_RNA, fill = Neuronal)) +
  geom_density(alpha = 0.7) +
  labs(x = "Number of Genes", y = "Density") +
  theme_bw() +
  theme(text = element_text(size = 15),
        axis.text = element_text(size = 10),
        legend.position = c(0.9, 0.9),
        legend.title= element_blank()) +
  NoGrid()

# save outputs ####
### UMAPs
#### cell types
ggsave(plot = all.dimplot.clusters,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/all.UMAP.celltypes.pdf",
       device = "pdf",
       height = 10,
       width = 12)
ggsave(plot = training.dimplot.clusters,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/training.UMAP.celltypes.pdf",
       device = "pdf",
       height = 10,
       width = 12)
ggsave(plot = testing.dimplot.clusters,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/testing.UMAP.celltypes.pdf",
       device = "pdf",
       height = 10,
       width = 12)
#### sexes
ggsave(plot = all.dimplot.sexes,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/all.UMAP.sexes.pdf",
       device = "pdf",
       height = 10,
       width = 12)
ggsave(plot = training.dimplot.sexes,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/training.UMAP.sexes.pdf",
       device = "pdf",
       height = 10,
       width = 12)
ggsave(plot = testing.dimplot.sexes,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/testing.UMAP.sexes.pdf",
       device = "pdf",
       height = 10,
       width = 12)
#### ChrY expression
ggsave(plot = all.dim.plot.y,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/all.UMAP.chrY.pdf",
       device = "pdf",
       height = 10,
       width = 20)
ggsave(plot = training.dim.plot.y,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/training.UMAP.chrY.pdf",
       device = "pdf",
       height = 10,
       width = 20)
ggsave(plot = testing.dim.plot.y,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/testing.UMAP.chrY.pdf",
       device = "pdf",
       height = 10,
       width = 20)
#### Xist expression
ggsave(plot = all.dim.plot.xist,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/all.UMAP.xist.pdf",
       device = "pdf",
       height = 10,
       width = 20)
ggsave(plot = training.dim.plot.xist,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/training.UMAP.xist.pdf",
       device = "pdf",
       height = 10,
       width = 20)
ggsave(plot = testing.dim.plot.xist,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/testing.UMAP.xist.pdf",
       device = "pdf",
       height = 10,
       width = 20)

### Violin plots
#### ChrY expression
ggsave(plot = all.vln.plot.y,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/all.vln.chrY.pdf",
       device = "pdf",
       height = 10,
       width = 12)
ggsave(plot = training.vln.plot.y,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/training.vln.chrY.pdf",
       device = "pdf",
       height = 10,
       width = 12)
ggsave(plot = testing.vln.plot.y,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/testing.vln.chrY.pdf",
       device = "pdf",
       height = 10,
       width = 12)
#### Xist expression
ggsave(plot = all.vln.plot.xist,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/all.vln.xist.pdf",
       device = "pdf",
       height = 10,
       width = 12)
ggsave(plot = training.vln.plot.xist,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/training.vln.xist.pdf",
       device = "pdf",
       height = 10,
       width = 12)
ggsave(plot = testing.vln.plot.xist,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/testing.vln.xist.pdf",
       device = "pdf",
       height = 10,
       width = 12)
#### DEGs
ggsave(plot = all.vln.plot.degs,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/all.vln.degs.pdf",
       device = "pdf",
       height = 10,
       width = 10)
ggsave(plot = training.vln.plot.degs,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/training.vln.degs.pdf",
       device = "pdf",
       height = 10,
       width = 10)
ggsave(plot = testing.vln.plot.degs,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/testing.vln.degs.pdf",
       device = "pdf",
       height = 10,
       width = 10)

### bar graphs
#### sex proportions
ggsave(plot = all.prop.sexes,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/all.bar.sexes.pdf",
       device = "pdf",
       height = 10,
       width = 10)
ggsave(plot = training.prop.sexes,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/training.bar.sexes.pdf",
       device = "pdf",
       height = 10,
       width = 10)
ggsave(plot = testing.prop.sexes,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/testing.bar.sexes.pdf",
       device = "pdf",
       height = 10,
       width = 10)
#### ncells
ggsave(plot = all.ncells.clusters,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/all.bar.ncells.pdf",
       device = "pdf",
       height = 10,
       width = 10)
ggsave(plot = training.ncells.clusters,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/training.bar.ncells.pdf",
       device = "pdf",
       height = 10,
       width = 10)
ggsave(plot = testing.ncells.clusters,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/testing.bar.ncells.pdf",
       device = "pdf",
       height = 10,
       width = 10)

### gene count distributions
ggsave(plot = all.gene.count.distb,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/all.distb.genes.pdf",
       device = "pdf",
       height = 10,
       width = 10)
ggsave(plot = training.gene.count.distb,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/training.distb.genes.pdf",
       device = "pdf",
       height = 10,
       width = 10)
ggsave(plot = testing.gene.count.distb,
       file = "/path/to/sex_prediction_model/output/object_summary_plots/testing.distb.genes.pdf",
       device = "pdf",
       height = 10,
       width = 10)


# sessionInfo ####
sessionInfo()
```

```{bash filename="geneexpression_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=geneexpression
#SBATCH --output=/path/to/sex_prediction_model/logs/geneexpression_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/geneexpression_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/geneexpression.R
```


### Mutual Information
To compare the information shared between a gene's expression and cell sex between neuronal and non-neuronal cell types, the mutual information of the two variables was calculated for the two broad cell types separately. Mutual information of transcript count data and cell sex, for all selected model genes, was calculated using the `mmi.pw()` function from the `mpmi` package in R (version 0.43.2.1). For calculation of gene's expression and cell sex mutual information content in neuronal or non-neuronal populations, the VTA training partition was separated into neuronal (Glut-Neuron-1, Glut-Neuron-2, Glut-Neuron-3, GABA-Neuron-1, GABA-Neuron-2, GABA-Neuron-3, DA-Neuron) and non-neuronal (Olig-1, Olig-2, Olig-3, Astrocyte, Polydendrocyte, Microglia, OPC-Olig-1, Mural, Endothelial) populations.

```{r filename="mutual_info.R"}
# Setup ####
## libraries
library(Seurat)
library(dplyr)
library(ggplot2)
library(tidyr)
library(infotheo)
library(mpmi)

## set seed
set.seed(1234)

## data
### VTA object
Rn7_VTA <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA.RDS")
#### training object
Rn7_VTA.training <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA_training.RDS")
#### testing object
Rn7_VTA.testing <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA_testing.RDS")

## genes
selected.genes <- read.csv("/path/to/sex_prediction_model/data/Boruta_final_decisions.csv") %>% 
  filter(finalDecision == "Confirmed") %>% 
  pull("variable")

# Pre-processing data ####
## global
Rn7_VTA@meta.data <- Rn7_VTA@meta.data %>%
  mutate(Neuronal = case_when(CellType %in% c("Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3", "DA-Neuron") ~ "Neuronal",
                              CellType %in% c("Olig-1", "Olig-2", "Olig-3", "Astrocyte", "Polydendrocyte", "Microglia", "OPC-Olig-1", "Mural", "Endothelial") ~ "Non-neuronal"))
Rn7_VTA@meta.data <- Rn7_VTA@meta.data %>% 
  mutate(Neuronal = factor(Neuronal, levels = c("Neuronal", "Non-neuronal")))

## training
Rn7_VTA.training@meta.data <- Rn7_VTA.training@meta.data %>%
  mutate(Neuronal = case_when(CellType %in% c("Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3", "DA-Neuron") ~ "Neuronal",
                              CellType %in% c("Olig-1", "Olig-2", "Olig-3", "Astrocyte", "Polydendrocyte", "Microglia", "OPC-Olig-1", "Mural", "Endothelial") ~ "Non-neuronal"))
Rn7_VTA.training@meta.data <- Rn7_VTA.training@meta.data %>% 
  mutate(Neuronal = factor(Neuronal, levels = c("Neuronal", "Non-neuronal")))

## testing
Rn7_VTA.testing@meta.data <- Rn7_VTA.testing@meta.data %>%
  mutate(Neuronal = case_when(CellType %in% c("Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3", "DA-Neuron") ~ "Neuronal",
                              CellType %in% c("Olig-1", "Olig-2", "Olig-3", "Astrocyte", "Polydendrocyte", "Microglia", "OPC-Olig-1", "Mural", "Endothelial") ~ "Non-neuronal"))
Rn7_VTA.testing@meta.data <- Rn7_VTA.testing@meta.data %>% 
  mutate(Neuronal = factor(Neuronal, levels = c("Neuronal", "Non-neuronal")))

# mpmpi calculation ####
## global ####
### extract count matrix
count.data <- as.data.frame(t(as.matrix(GetAssayData(object = Rn7_VTA,slot = "data",assay = "RNA")))) %>% 
  select(all_of(selected.genes))
### create cell lists for neuronal and non-neuronal cells
neuronal.cells <- Rn7_VTA@meta.data %>% filter(Neuronal == "Neuronal") %>% rownames()
nonneuronal.cells <- Rn7_VTA@meta.data %>% filter(Neuronal != "Neuronal") %>% rownames()

### create count dfs for neuronal and non-neuronal cells
count.data.neurons <- count.data[neuronal.cells,] 
count.data.nonneurons <- count.data[nonneuronal.cells,] 

### calculate mutual info
minfo <- lapply(selected.genes, function(gene){
  # calculate for neuronal cells
  neuronal.info <- mmi.pw(count.data.neurons %>% select(gene),
                          Rn7_VTA@meta.data[neuronal.cells,] %>% select(Sex))$mi 
  # calculate for non-neuronal cells
  nonneuronal.info <- mmi.pw(count.data.nonneurons %>% select(gene),
                             Rn7_VTA@meta.data[nonneuronal.cells,] %>% select(Sex))$mi
  # return vector of gene, minfo for neuronal, and minfo for non-neuronal
  return(c(gene, neuronal.info, nonneuronal.info))
})

### merge to dataframe
minfo.global.df <- as.data.frame(do.call(rbind,minfo))
### modify dataframe
colnames(minfo.global.df) <- c("Gene","neuronal", "nonneuronal") #set column names to be informative
minfo.global.df <- minfo.global.df %>%
  mutate(neuronal = neuronal %>% as.numeric(),
         nonneuronal = nonneuronal %>% as.numeric())
#### pivot longer
minfo.global.df.long <- minfo.global.df %>% 
  pivot_longer(cols = neuronal:nonneuronal,
               names_to = "cell.type",
               values_to = "mutual.info")


## training ####
### extract count matrix
count.data <- as.data.frame(t(as.matrix(GetAssayData(object = Rn7_VTA.training,slot = "data",assay = "RNA")))) %>% 
  select(all_of(selected.genes))
### create cell lists for neuronal and non-neuronal cells
neuronal.cells <- Rn7_VTA.training@meta.data %>% filter(Neuronal == "Neuronal") %>% rownames()
nonneuronal.cells <- Rn7_VTA.training@meta.data %>% filter(Neuronal != "Neuronal") %>% rownames()

### create count dfs for neuronal and non-neuronal cells
count.data.neurons <- count.data[neuronal.cells,] 
count.data.nonneurons <- count.data[nonneuronal.cells,] 

### calculate mutual info
minfo <- lapply(selected.genes, function(gene){
  # calculate for neuronal cells
  neuronal.info <- mmi.pw(count.data.neurons %>% select(gene),
                          Rn7_VTA.training@meta.data[neuronal.cells,] %>% select(Sex))$mi 
  # calculate for non-neuronal cells
  nonneuronal.info <- mmi.pw(count.data.nonneurons %>% select(gene),
                             Rn7_VTA.training@meta.data[nonneuronal.cells,] %>% select(Sex))$mi
  # return vector of gene, minfo for neuronal, and minfo for non-neuronal
  return(c(gene, neuronal.info, nonneuronal.info))
})

### merge to dataframe
minfo.training.df <- as.data.frame(do.call(rbind,minfo))
### modify dataframe
colnames(minfo.training.df) <- c("Gene","neuronal", "nonneuronal") #set column names to be informative
minfo.global.df <- minfo.training.df %>%
  mutate(neuronal = neuronal %>% as.numeric(),
         nonneuronal = nonneuronal %>% as.numeric())
#### pivot longer
minfo.training.df.long <- minfo.training.df %>% 
  pivot_longer(cols = neuronal:nonneuronal,
               names_to = "cell.type",
               values_to = "mutual.info")

## testing ####
### extract count matrix
count.data <- as.data.frame(t(as.matrix(GetAssayData(object = Rn7_VTA.testing,slot = "data",assay = "RNA")))) %>% 
  select(all_of(selected.genes))
### create cell lists for neuronal and non-neuronal cells
neuronal.cells <- Rn7_VTA.testing@meta.data %>% filter(Neuronal == "Neuronal") %>% rownames()
nonneuronal.cells <- Rn7_VTA.testing@meta.data %>% filter(Neuronal != "Neuronal") %>% rownames()

### create count dfs for neuronal and non-neuronal cells
count.data.neurons <- count.data[neuronal.cells,] 
count.data.nonneurons <- count.data[nonneuronal.cells,] 

### calculate mutual info
minfo <- lapply(selected.genes, function(gene){
  # calculate for neuronal cells
  neuronal.info <- mmi.pw(count.data.neurons %>% select(gene),
                          Rn7_VTA.testing@meta.data[neuronal.cells,] %>% select(Sex))$mi 
  # calculate for non-neuronal cells
  nonneuronal.info <- mmi.pw(count.data.nonneurons %>% select(gene),
                             Rn7_VTA.testing@meta.data[nonneuronal.cells,] %>% select(Sex))$mi
  # return vector of gene, minfo for neuronal, and minfo for non-neuronal
  return(c(gene, neuronal.info, nonneuronal.info))
})

### merge to dataframe
minfo.testing.df <- as.data.frame(do.call(rbind,minfo))
### modify dataframe
colnames(minfo.testing.df) <- c("Gene","neuronal", "nonneuronal") #set column names to be informative
minfo.global.df <- minfo.testing.df %>%
  mutate(neuronal = neuronal %>% as.numeric(),
         nonneuronal = nonneuronal %>% as.numeric())
#### pivot longer
minfo.testing.df.long <- minfo.testing.df %>% 
  pivot_longer(cols = neuronal:nonneuronal,
               names_to = "cell.type",
               values_to = "mutual.info")


# Write outputs ####
## global
write.csv(minfo.global.df.long, "/path/to/sex_prediction_model/data/mutualinfo.df.csv")
## training
write.csv(minfo.training.df.long, "/path/to/sex_prediction_model/data/mutualinfo.training.df.csv")
## testing
write.csv(minfo.testing.df.long, "/path/to/sex_prediction_model/data/mutualinfo.testing.df.csv")

# SessionInfo ####
sessionInfo()
```

```{bash filename="mutual_info_run.R"}
#!/bin/bash
#
#SBATCH --job-name=mutualinfo
#SBATCH --output=/path/to/sex_prediction_model/logs/mutual_info_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/mutual_info_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=short
#SBATCH --time=12:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/mutual_info.R
```


## Model Training
To train cell sex prediction models, models were fitted using the VTA training partition log normalized gene counts as predictor variables and cell sex as the outcome variable. The Xist model made binary female or male cell sex predictions based on the presence or absence of *Xist* (*ENSRNOG00000065796*) counts. Reciprocally, the Chromosome Y classifier made binary male or female cell sex predictions based on the presence or absence of counts from any gene on the Y chromosome. The logistic regression model was fit to the training data with the `glm()` function from the `stats` package (version 4.2.0). To assess training for a range of hyperparameters the random forest, support vector machine, and multilayer perceptron models were trained with the `train()` function of the `caret` package (version 6.0-94). Training parameters were set to output cell sex class probabilities and perform 3x repeated 10-fold cross-validation using `trainControl()` with parameters `method = "repeatedcv", number = 10, repeats = 3, classProbs = T, allowParallel = T`. Ranges for model hyperparameters for each model were specified using tuning grids defined for each model, described in detail below. Model accuracy was used to select the optimal configuration for each model.


### Logistic Regression
The logistic regression model was fit to the training data with the `glm()` function from the `stats` package (version 4.2.0) with cell sex as the outcome variable, all ‘Confirmed’ important genes as predictor variables, and the family parameter set to “binomial”.

```{r filename="logistic_regression_training.R"}
# Set up ####
## libraries
library(caret)
library(tidyverse)

## set seed
set.seed(1234)

## load data
### training dataframe
training <- read.csv("/path/to/sex_prediction_model/data/training_count_data.csv", row.names = 1)
training$Identity_bin <- as.factor(training$Identity_bin)

# Train Model ####
lr_model <- glm(Identity_bin ~ .,
                      data = training,
                      family = "binomial")
# Summary
summary(lr_model)

# Write out files ####
saveRDS(lr_model, file = "/path/to/sex_prediction_model/data/models/lr_model.RDS")

# print session Info ####
sessionInfo()
```

```{bash filename="logistic_regression_training_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=logistic_regression_training
#SBATCH --output=/path/to/sex_prediction_model/logs/logistic_regression_training_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/logistic_regression_training_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/logistic_regression_training.R
```


### Random Forest
The random forest model was trained with `method = "rf"` and a constant number of 1000 trees `ntrees = 1000` as `train()` function parameters. To tune the number of variables randomly sampled at each split, the custom tuning grid assessed a range of “mtry” values from 2-334 by steps of 12. The final optimal model selected for accuracy used `ntree = 1000`, and `mtry = 34`.

```{r filename="randomforest_training.R"}
# Setup ####
library(randomForest)
library(ROCR)
library(caret)
library(tidyverse)
library(doParallel)

## set seed
set.seed(1234)
## setup parallel
cl <- makePSOCKcluster(10)
registerDoParallel(cl)

## load data
### training dataframe
training <- read.csv("/path/to/sex_prediction_model/data/training_count_data.csv", row.names = 1)
training$Identity_bin <- recode(training$Identity_bin, `0` = "Male", `1` = "Female")
training$Identity_bin <- factor(training$Identity_bin, levels = c("Male", "Female"))

# Train Model ####
mtry_values <- seq(from = 2, to = 334, by = 12)

# Generate all combinations
tune.grid <- expand.grid(mtry = mtry_values)

train.ctrl <- trainControl(method = "repeatedcv",
                           number = 10,
                           repeats = 3,
                           classProbs = T,
                           allowParallel = T)
rf_model <- train(Identity_bin ~ ., data = training, 
                  method = "rf",
                  trControl = train.ctrl,
                  tuneGrid = tune.grid,
                  ntree = 1000)
rf_model

stopCluster(cl)

# Write out files ####
saveRDS(rf_model, file = "/path/to/sex_prediction_model/data/models/rf_model.RDS")

# print session Info ####
sessionInfo()
```

```{bash filename="randomforest_training_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=randomforest_training
#SBATCH --output=/path/to/sex_prediction_model/logs/randomforest_training_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/randomforest_training_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=long
#SBATCH --time=150:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/randomforest_training.R
```


### Support Vector Machine
The support vector machine (SVM) model was trained with `method = "svmRadial"` as a parameter of the `train()` function, to specify an SVM model with a radial basis function. A custom tuning grid of hyperparameters specifying “sigma” values from 0.0001 to 1, where steps increase by a factor of 10 with each subsequent term, and C values from 0.1 to 10 (0.01,0.1,0.2,0.5,1,1.5,2,5,10), was utilized for model training. The final optimal model selected for accuracy used `sigma = 1e-3` and `C = 5`.

```{r filename="svm_training.R"}
# Setup ####
library(kernlab)
library(ROCR)
library(caret)
library(tidyverse)
library(doParallel)

## set seed
set.seed(1234)
## setup parallel
cl <- makePSOCKcluster(10)
registerDoParallel(cl)

## load data
### training data frame
training <- read.csv("/path/to/sex_prediction_model/data/training_count_data.csv", row.names = 1)
training$Identity_bin <- recode(training$Identity_bin, `0` = "Male", `1` = "Female")
training$Identity_bin <- factor(training$Identity_bin, levels = c("Male", "Female"))

# Train Model ####
## Create vectors for sigma and C
sigma_values <- c(0.0001,0.001,0.01,0.1,1)
C_values <- c(c(0.01,0.1,0.2,0.5,1,1.5,2,5,10))

## Generate training grid
train.grid <- expand.grid(sigma = sigma_values, C = C_values)

## create training control parameters
train.ctrl <- trainControl(method = "repeatedcv",
                           number = 10,
                           repeats = 3,
                           classProbs = T,
                           allowParallel = T)

svm_model <- train(Identity_bin ~ ., data = training, 
                   method = "svmRadial",
                   verbose = T,
                   trControl = train.ctrl,
                   tuneGrid = train.grid)

svm_model

stopCluster(cl)
# Write out files ####
saveRDS(svm_model, file = "/path/to/sex_prediction_model/data/models/svm_rad_model.RDS")

# print session Info ####
sessionInfo()
```

```{bash filename="svm_training_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=svm_training
#SBATCH --output=/path/to/sex_prediction_model/logs/svm_training_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/svm_training_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=long
#SBATCH --time=150:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/svm_training.R
```


### Multilayer Perceptron with weights
A multi-layer perceptron with weight decay was trained with `method = "mlpWeightDecayML"` as `train()` function parameters. Model hyperparameters for training were tuned using a custom tuning grid specifying ranges for the number of nodes for each layer 1 (1,5,10,15,20), layer 2 (0,2,5,8,10), layer 3 (0,1,2,4,5), and weight decay `decay` values (0,0.05,0.1,0.15,0.2). Only hyperparameter configurations with decreasing nodes in successive layers were evaluated. The final optimal model selected for accuracy was trained using `layer1 = 20`, `layer2 = 2`, `layer3 = 0`, and `decay = 0`.

```{r filename="mlp_training.R"}
# Set up ####
## libraries
library(RSNNS)
library(ROCR)
library(caret)
library(tidyverse)
library(doParallel)

## set seed
set.seed(1234)
## setup parallel
cl <- makePSOCKcluster(10)
registerDoParallel(cl)

## load data
### training dataframe
training <- read.csv("/path/to/sex_prediction_model/data/training_count_data.csv", row.names = 1)
training$Identity_bin <- recode(training$Identity_bin, `0` = "Male", `1` = "Female")
training$Identity_bin <- factor(training$Identity_bin, levels = c("Male", "Female"))

# Train Model ####
# Create vectors for layer1, layer2, and decay
layer1_values <- c(1,seq(from = 5, to = 20, by = 5))
layer2_values <- c(0, round(layer1_values / 2)) %>% unique()
layer3_values <- round(layer2_values / 2)  
decay_values <- seq(from = 0, to = 0.2, by = 0.05)

# Generate all combinations
train.grid <- expand.grid(layer1 = layer1_values,
                                layer2 = layer2_values,
                                layer3 = layer3_values,
                                decay = decay_values)

# Filter rows where layer2 is smaller than layer1
train.grid <- train.grid[train.grid$layer2 < train.grid$layer1, ]

# Filter rows where layer3 is smaller than layer2
train.grid <- train.grid[train.grid$layer3 < train.grid$layer2, ]

train.ctrl <- trainControl(method = "repeatedcv",
                          number = 10,
                          repeats = 3,
                          classProbs = T,
                          allowParallel = T)
mlp_model <- caret::train(Identity_bin ~ ., data = training, 
                   method = "mlpWeightDecayML",
                   trControl = train.ctrl,
                   tuneGrid = train.grid)

mlp_model

stopCluster(cl)
# Write out files ####
saveRDS(mlp_model, file = "/path/to/sex_prediction_model/data/models/mlpwdml_model.RDS")

# print session Info ####
sessionInfo()
```

```{bash filename="mlp_training_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=mlp_training
#SBATCH --output=/path/to/sex_prediction_model/logs/mlp_training_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/mlp_training_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=long
#SBATCH --time=150:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/mlp_training.R
```


### Simple Y expression classifier
The ChrY model made binary female or male cell sex predictions based on the presence or absence of chromosome Y gene counts. To quantify this, for all cells we sum read counts for all genes with annotations on the Y chromosome. Male cell classifications are made based on weather this is sum is greater than 0, and female cells if this sum is equal to 0. 

```{r filename="chrY_classifier.R"}
# Setup ####
## libraries
library(ggplot2)
library(dplyr)
library(tibble)
library(Seurat)
library(pROC)
library(caret)

## data
### training object data
training.object <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA_training.RDS")
### testing object data
testing.object <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA_testing.RDS")

### gene chromosome data
Rn7.gtf <- rtracklayer::import("/path/to/sex_prediction_model/data/Rattus_norvegicus.mRatBN7.2.105.gtf")
Rn7.gtf <- as.data.frame(Rn7.gtf)

## functions
y.count <- function(srat.object){
  # load gene expression count data
  srat.counts <- as.data.frame(t(as.matrix(GetAssayData(object = srat.object, slot = "data", assay = "RNA"))))
  
  # load gene annotations
  Rn7.gtf <- rtracklayer::import("/path/to/sex_prediction_model/data/Rattus_norvegicus.mRatBN7.2.105.gtf")
  Rn7.gtf <- as.data.frame(Rn7.gtf)
  
  # select Y chromosome genes
  y.genes <- Rn7.gtf %>% #from Rn7 gene annotations
    filter(seqnames == "Y") %>% #filter for chrY only
    select(gene_id, gene_name) %>% #select gene ids and names
    mutate(gene_name = coalesce(gene_name, gene_id)) %>% #replace NA name values with gene ID
    pull(gene_name) %>% #pull gene name values
    unique() #only unique values, returns 27 genes
  
  # create cumulative expresion of Y genes
  y.counts <- srat.counts %>%
    select(any_of(y.genes)) %>%
    rowSums() %>% data.frame()
  ### set column name
  colnames(y.counts) <- c("y.counts")
  
  return(y.counts)
}
y.class.threshold <- function(srat.object){
  class.roc <- roc(srat.object$Sex,srat.object$y.counts)
  threshold <- coords(class.roc, x = "best")
  return(threshold$threshold)
}
y.count.classify <- function(srat.object, threshold){
  classifications <- case_when(srat.object$y.counts > threshold ~ "Male",
                               TRUE ~ "Female")
  return(classifications)
}


# Prepare classifiers ####
## Sum chrY counts
training.object$y.counts <- y.count(training.object)

## chrY summary stats
### distributions
#### overall
overall.distb <- ggplot(data = training.object@meta.data, mapping = aes(x = y.counts)) +
  geom_histogram(bins = 20, color = "black", fill = "lightgrey") +
  labs(title = "Chromosome Y gene count distribution", x = "Gene count", y = "Cell count") +
  theme_bw()

#### split by sex
wrap.distb <- ggplot(data = training.object@meta.data, mapping = aes(x = y.counts)) +
  geom_histogram(bins = 20, color = "black", fill = "lightgrey") +
  labs(title = "Chromosome Y gene count distribution", x = "Gene count", y = "Cell count") +
  facet_wrap(~ Sex) +
  theme_bw()

#### save plots
ggsave(plot = overall.distb,
       filename = "/path/to/sex_prediction_model/output/Ydistb.training.all.pdf",
       height = 5,
       width = 5)

ggsave(plot = wrap.distb,
       filename = "/path/to/sex_prediction_model/output/Ydistb.training.split.pdf",
       height = 5,
       width = 10)


### summary statistics
#### overall
overall.stats <- data.frame(min = min(training.object$y.counts), 
                            Q1 = quantile(training.object$y.counts, 0.25),
                            median = median(training.object$y.counts),
                            mean = mean(training.object$y.counts),
                            Q3 = quantile(training.object$y.counts, 0.75),
                            max = max(training.object$y.counts))
rownames(overall.stats) <- c("Overall")

#### split by sex
summary.stats <- training.object@meta.data %>% 
  group_by(Sex) %>% 
  summarize(
    min = min(y.counts),
    Q1 = quantile(y.counts, 0.25),
    median = median(y.counts),
    mean = mean(y.counts),
    Q3 = quantile(y.counts, 0.75),
    max = max(y.counts)
  ) %>% 
  data.frame() %>% 
  column_to_rownames(var = "Sex")

#### bind 
stats.df <- bind_rows(summary.stats, overall.stats)
#### write out
write.csv(stats.df, file = "/path/to/sex_prediction_model/output/Ydistb.training.sumstats.csv")

## Set classification threshold
### ROC curve
simple.roc <- roc(training.object$Sex,training.object$y.counts)

### save plot 
roc.plot <- ggroc(data = simple.roc) +
  geom_abline(slope = 1, intercept = 1, linetype = "dashed") +
  theme_bw()
ggsave(filename = "/path/to/sex_prediction_model/output/Ydistb.training.roc.pdf",
       plot = roc.plot,
       height = 5,
       width = 5)

### set threshold
threshold <- y.class.threshold(training.object)


# Make classification predictions ####
## sum chrY counts
testing.object$y.counts <- y.count(testing.object)
## make precition
testing.object$Sex.prediction <- y.count.classify(testing.object, 0)
testing.object$Sex.roc.prediction <- y.count.classify(testing.object, threshold)
## save predictions
testing.predictions <- testing.object@meta.data %>% select(Sex, y.counts, Sex.prediction, Sex.roc.prediction)
write.csv(testing.predictions, file = "/path/to/sex_prediction_model/output/Yclass.predictions.csv")


# Evaluate performance ####
## make Sex and predicted Sex a factor
testing.object@meta.data <- testing.object@meta.data %>% mutate(Sex = factor(testing.object$Sex, levels = c("Male", "Female")),
                                                                Sex.prediction = factor(testing.object$Sex.prediction, levels = c("Male", "Female")),
                                                                Sex.roc.prediction = factor(testing.object$Sex.roc.prediction, levels = c("Male", "Female")))

print("Threshold 0 predictions")
confusionMatrix(testing.object$Sex.prediction, testing.object$Sex)

print(paste0("Threshold ", threshold, " predictions"))
confusionMatrix(testing.object$Sex.roc.prediction, testing.object$Sex)


# sessionInfo ####
sessionInfo()
```

```{bash filename="chrY_classifier_run.R"}
#!/bin/bash
#
#SBATCH --job-name=chrY_classifier
#SBATCH --output=/path/to/sex_prediction_model/logs/chrY_classifier_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/chrY_classifier_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/chrY_classifier.R
```


### Simple Xist expression classifier 
The Xist model made binary female or male cell sex predictions based on the presence or absence of *Xist* (*ENSRNOG00000065796*) counts. To quantify this, for all cells we consider read counts for *Xist*. Female cell classifications are made based on weather this is sum is greater than 0, and male cells if this sum is equal to 0. 

```{r filename="Xist_classifier.R"}
# Setup ####
## libraries
library(ggplot2)
library(dplyr)
library(tibble)
library(Seurat)
library(pROC)
library(caret)

## data
### training object data
training.object <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA_training.RDS")
### testing object data
testing.object <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA_testing.RDS")

## functions
Xist.count <- function(srat.object){
  # load gene expression count data
  Xist.counts <- as.data.frame(t(as.matrix(GetAssayData(object = srat.object, slot = "data", assay = "RNA")))) %>%
    pull("ENSRNOG00000065796") # pull out Xist (named as ENSRNOG00000065796)
  
  return(Xist.counts)
}
Xist.class.threshold <- function(srat.object){
  class.roc <- roc(srat.object$Sex,srat.object$Xist.counts, levels = c("Male", "Female"))
  threshold <- coords(class.roc, x = "best")
  return(threshold$threshold)
}
Xist.count.classify <- function(srat.object, threshold){
  classifications <- case_when(srat.object$Xist.counts > threshold ~ "Female",
                               TRUE ~ "Male")
  return(classifications)
}


# Prepare classifier ####
## Sum Xist counts
training.object$Xist.counts <- Xist.count(training.object)

## Xist summary stats
### distributions
#### overall
overall.distb <- ggplot(data = training.object@meta.data, mapping = aes(x = Xist.counts)) +
  geom_histogram(bins = 20, color = "black", fill = "lightgrey") +
  labs(title = "Xist gene count distribution", x = "Gene count", y = "Cell count") +
  theme_bw()

#### split by sex
wrap.distb <- ggplot(data = training.object@meta.data, mapping = aes(x = Xist.counts)) +
  geom_histogram(bins = 20, color = "black", fill = "lightgrey") +
  labs(title = "Xist gene count distribution", x = "Gene count", y = "Cell count") +
  facet_wrap(~ Sex) +
  theme_bw()

#### save plots
ggsave(plot = overall.distb,
       filename = "/path/to/sex_prediction_model/output/Xist.distb.training.all.pdf",
       height = 5,
       width = 5)

ggsave(plot = wrap.distb,
       filename = "/path/to/sex_prediction_model/output/Xist.distb.training.split.pdf",
       height = 5,
       width = 10)


### summary statistics
#### overall
overall.stats <- data.frame(min = min(training.object$Xist.counts), 
                            Q1 = quantile(training.object$Xist.counts, 0.25),
                            median = median(training.object$Xist.counts),
                            mean = mean(training.object$Xist.counts),
                            Q3 = quantile(training.object$Xist.counts, 0.75),
                            max = max(training.object$Xist.counts))
rownames(overall.stats) <- c("Overall")

#### split by sex
summary.stats <- training.object@meta.data %>% 
  group_by(Sex) %>% 
  summarize(
    min = min(Xist.counts),
    Q1 = quantile(Xist.counts, 0.25),
    median = median(Xist.counts),
    mean = mean(Xist.counts),
    Q3 = quantile(Xist.counts, 0.75),
    max = max(Xist.counts)
  ) %>% 
  data.frame() %>% 
  column_to_rownames(var = "Sex")

#### bind 
stats.df <- bind_rows(summary.stats, overall.stats)
#### write out
write.csv(stats.df, file = "/path/to/sex_prediction_model/output/Xist.distb.training.sumstats.csv")

## Set classification threshold
### ROC curve
simple.roc <- roc(training.object$Sex,training.object$Xist.counts,
                  levels = c("Female", "Male"),
                  direction = ">"
)

### save plot 
roc.plot <- 
  ggroc(data = simple.roc, legacy.axes = F) +
  geom_abline(slope = 1, intercept = 1, linetype = "dashed") +
  theme_bw()
ggsave(filename = "/path/to/sex_prediction_model/output/Xist.training.roc.pdf",
       plot = roc.plot,
       height = 5,
       width = 5)

### set threshold
threshold <- Xist.class.threshold(training.object)


# Make classification predictions ####
## sum chrY counts
testing.object$Xist.counts <- Xist.count(testing.object)
## make precition
testing.object$Sex.prediction <- Xist.count.classify(testing.object, 0)
testing.object$Sex.roc.prediction <- Xist.count.classify(testing.object, threshold)
## save predictions
testing.predictions <- testing.object@meta.data %>% select(Sex, Xist.counts, Sex.prediction, Sex.roc.prediction)
write.csv(testing.predictions, file = "/path/to/sex_prediction_model/output/Xist.class.predictions.csv")


# Evaluate performance ####
## make Sex and predicted Sex a factor
testing.object@meta.data <- testing.object@meta.data %>% mutate(Sex = factor(testing.object$Sex, levels = c("Male", "Female")),
                                                                Sex.prediction = factor(testing.object$Sex.prediction, levels = c("Male", "Female")),
                                                                Sex.roc.prediction = factor(testing.object$Sex.roc.prediction, levels = c("Male", "Female")))

print("Threshold 0 predictions")
confusionMatrix(testing.object$Sex.prediction, testing.object$Sex)

print(paste0("Threshold ", threshold, " predictions"))
confusionMatrix(testing.object$Sex.roc.prediction, testing.object$Sex)


# sessionInfo ####
sessionInfo()
```

```{bash filename="Xist_classifier_run.R"}
#!/bin/bash
#
#SBATCH --job-name=Xist_classifier
#SBATCH --output=/path/to/sex_prediction_model/logs/Xist_classifier_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/Xist_classifier_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/Xist_classifier.R
```


## Model Evaluation
Model performance was evaluated using the VTA testing partition and the NAc dataset. Neuronal and non-neuronal models were evaluated using respective subsets of the VTA testing data partition. Overall model classification accuracy was calculated as the number of correct classifications divided by the number of total classifications made. For all models, the receiver operating characteristic (ROC) curve and the area under the ROC (AUC-ROC) were used to evaluate the trade-off of sensitivity and specificity rates. ROC curve and AUC values were calculated using the `roc()` function of the `pROC` package in R. True-positive and false-positive rates were calculated using males as the “positive” class.


### Overall performance assessment 
Overall model performance of models trained with the VTA training partition was assessed first using the VTA testing partition. Models were evaluated based on their overall accuracy (proportion of correct classifications), as well as sensitivity and speciticity with the receiver operating characteristic (ROC) curve and the area under the ROC (AUC-ROC). In the evaluation of sensitivity and specificity we use male cells as the "positive" class, however it would be equally valid to use females as the "positive" class. The important thing is that this choice of "positive" class remains consistent for all model evaluations.

```{r filename="overall_performance.R"}
# Setup ####
## libraries
library(randomForest)
library(kernlab)
library(RSNNS)
library(caret)
library(ROCR)
library(pROC)
library(ggplot2)
library(dplyr)
library(tidyr)

## set seed
set.seed(1234)

## data
### models
svm_model <- readRDS("/path/to/sex_prediction_model/data/models/svm_rad_model.RDS")
rf_model <- readRDS("/path/to/sex_prediction_model/data/models/rf_model.RDS")
mlp_model <- readRDS("/path/to/sex_prediction_model/data/models/mlpwdml_model.RDS")
lr_model <- readRDS("/path/to/sex_prediction_model/data/models/lr_model.RDS")
chrY_model <- read.csv("/path/to/sex_prediction_model/output/Yclass.predictions.csv", row.names = 1)
Xist_model <- read.csv("/path/to/sex_prediction_model/output/Xist.class.predictions.csv", row.names = 1)

### testing data
testing <- read.csv("/path/to/sex_prediction_model/data/test_count_data.csv", row.names = 1)
#### make character ID bin
testing$Identity_bin_char <- recode(testing$Identity_bin, `0` = "Male", `1` = "Female")
testing$Identity_bin_char <- factor(testing$Identity_bin_char, levels = c("Male", "Female"))
#### make ID bin a factor
testing$Identity_bin <- as.factor(testing$Identity_bin)

# Predictions ####
## logistic regression
lr_prediction <- predict(lr_model,testing[,1:285], type = "response")
## support vector machine
svm_prediction <- predict(svm_model,testing[,1:285], type = "prob")
## random forrest
rf_prediction <- predict(rf_model,testing[,1:285], type = "prob")
## multi-layer perceptron
mlp_prediction <- predict(mlp_model,testing[,1:285], type = "prob")
## chrY expression based prediction
chrY_prediction <- chrY_model$y.counts
## Xist expression based prediction
Xist_prediction <- Xist_model$Xist.counts


# ROC curves ####
## calculate ROC
lr_roc <- roc(testing$Identity_bin,lr_prediction, levels = c(1,0))
svm_roc <- roc(testing$Identity_bin_char, svm_prediction[,2], levels = c("Female", "Male"))
rf_roc <- roc(testing$Identity_bin_char, rf_prediction[,2], levels = c("Female", "Male"))
mlp_roc <- roc(testing$Identity_bin_char, mlp_prediction[,2], levels = c("Female", "Male"))
chrY_roc <- roc(testing$Identity_bin_char, chrY_prediction, levels = c("Female", "Male"))
Xist_roc <- roc(testing$Identity_bin_char, Xist_prediction, levels = c("Female", "Male"), direction = ">")

## plot ROC curves
g <- ggroc(data = list(`Chr Y` = chrY_roc,
                       `Xist` = Xist_roc,
                       `Logistic Regression` = lr_roc,
                       `SVM` = svm_roc,
                       `Random Forest` = rf_roc,
                       `MLP` = mlp_roc)) +
  geom_abline(slope = 1, intercept = 1, linetype = "dashed") +
  labs(color = "Model") +
  theme_bw()
ggsave(filename = "/path/to/sex_prediction_model/output/ROC_curves.pdf",
       plot = g + theme(text = element_text(size = 20)),
       height = 10,
       width = 12,
       device = "pdf")

## save AUC values
auc.table <- data.frame(AUC = c(chrY_roc[["auc"]] %>% as.numeric(),
                                Xist_roc[["auc"]] %>% as.numeric(),
                                lr_roc[["auc"]] %>% as.numeric(),
                                svm_roc[["auc"]] %>% as.numeric(),
                                rf_roc[["auc"]] %>% as.numeric(),
                                mlp_roc[["auc"]] %>% as.numeric()))
rownames(auc.table) <- c("Chr Y", "Xist", "Logistic Regression","SVM", "Random Forest", "MLP")
write.csv(auc.table, "/path/to/sex_prediction_model/output/AUCs_table.csv")

# Confusion Matrices ####
## make precitions using threshold
svm_prediction$class <- ifelse(svm_prediction$Female >0.5, "Female", "Male")
svm_prediction$class <- factor(svm_prediction$class, levels = c("Male", "Female"))

rf_prediction$class <- ifelse(rf_prediction$Female >0.5, "Female", "Male")
rf_prediction$class <- factor(rf_prediction$class, levels = c("Male", "Female"))

mlp_prediction$class <- ifelse(mlp_prediction$Female >0.5, "Female", "Male")
mlp_prediction$class <- factor(mlp_prediction$class, levels = c("Male", "Female"))

lr_prediction <- ifelse(lr_prediction >0.5, 1, 0)
lr_prediction <- as.factor(lr_prediction)

chrY_prediction <- factor(chrY_model$Sex.prediction, levels = c("Male", "Female"))

Xist_prediction <- factor(Xist_model$Sex.prediction, levels = c("Male", "Female"))


## make confusion matrices
svm_confusion <- caret::confusionMatrix(svm_prediction$class,testing$Identity_bin_char)
rf_confusion <- caret::confusionMatrix(rf_prediction$class,testing$Identity_bin_char)
mlp_confusion <- caret::confusionMatrix(mlp_prediction$class,testing$Identity_bin_char)
lr_confusion <- caret::confusionMatrix(lr_prediction, testing$Identity_bin)
chrY_confusion <- caret::confusionMatrix(chrY_prediction, testing$Identity_bin_char)
Xist_confusion <- caret::confusionMatrix(Xist_prediction, testing$Identity_bin_char)

## print confusion matrices to log
print("SVM confusion Matrix: ")
svm_confusion
cat("\n")

print("Random Forest confusion Matrix: ")
rf_confusion
cat("\n")

print("MLP confusion matrix: ")
mlp_confusion
cat("\n")

print("Logistic Regression confusion matrix: ")
lr_confusion
cat("\n")

print("Chr Y confusion matrix: ")
chrY_confusion
cat("\n")

print("Xist confusion matrix: ")
Xist_confusion
cat("\n")

## make accuracy table
acc.table <- data.frame(Accuracy = c(chrY_confusion[["overall"]][["Accuracy"]],
                                     Xist_confusion[["overall"]][["Accuracy"]],
                                     lr_confusion[["overall"]][["Accuracy"]],
                                     svm_confusion[["overall"]][["Accuracy"]],
                                     rf_confusion[["overall"]][["Accuracy"]],
                                     mlp_confusion[["overall"]][["Accuracy"]]))
rownames(acc.table) <- c("Chr Y","Xist", "Logistic Regression", "SVM", "Random Forest", "MLP")
write.csv(acc.table, "/path/to/sex_prediction_model/output/Accuracy_table.csv")

## stacked bar plot of prediction accuracies
### make list of confusion matrices
confusion.list <- list(ChrY = chrY_confusion,
                       Xist = Xist_confusion,
                       `Logistic Regression` = lr_confusion,
                       SVM = svm_confusion,
                       `Random Forest` = rf_confusion,
                       MLP = mlp_confusion)

### extract values to data frame with values for reference_prediction
confusion.df <- data.frame(model = c("Chr Y","Xist", "Logistic Regression", "SVM", "Random Forest", "MLP"),
                           Male_correct = lapply(confusion.list, function(x){x[["table"]][1,1]}) %>% unlist(),
                           Female_incorrect = lapply(confusion.list, function(x){x[["table"]][1,2]}) %>% unlist(),
                           Male_incorrect = lapply(confusion.list, function(x){x[["table"]][2,1]}) %>% unlist(),
                           Female_correct = lapply(confusion.list, function(x){x[["table"]][2,2]}) %>% unlist())

### convert to long format and split reference level and prediction
confusion.df.long <- confusion.df %>%
  pivot_longer(cols = Male_correct:Female_correct,
               names_to = "prediction",
               values_to = "count") %>%
  separate(col = prediction,
           into = c("reference","prediction"),
           sep = "_")

### convert variables to factors
confusion.df.long <- confusion.df.long %>% mutate(reference = factor(reference, levels = c("Male", "Female")),
                                                  prediction = factor(prediction, levels = c("incorrect","correct")),
                                                  model = factor(model, levels = rev(c("Chr Y","Xist", "Logistic Regression", "SVM", "Random Forest", "MLP"))))

### create stacked bar plot of predictions split by sex
confusion.plot <- ggplot(data = confusion.df.long, mapping = aes(x=model, y=count, fill=prediction)) + 
  geom_bar(position="fill", stat="identity") +
  facet_wrap( ~ reference) +
  theme_bw() +
  coord_flip() +
  labs(title = "Confuson plot", x = "Model", y = "Proportion") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())

### save
ggsave(plot = confusion.plot,
       file = "/path/to/sex_prediction_model/output/confusionplot.pdf",
       height = 7,
       width = 10,
       device = "pdf")

# sessionInfo
sessionInfo()
```

```{bash filename="overall_performance_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=overall_performance
#SBATCH --output=/path/to/sex_prediction_model/logs/overall_performance_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/overall_performance_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/overall_performance.R
```


### Cell type specific performance asessment
We further examine model performance with respect to the neuronal and non-neuronal cell populations of our dataset, as well as the more granular cell type populations (e.g. DA-Neuron, Glut-Neuron-1, Astrocyte, ...) using the same metrics as our overall evaluation. To conduct these cell type-specific evaluations, we calculate performance metrics for each cell type subset of interest.

```{r filename="celltype_split_performance.R"}
# Setup ####
## libraries
library(Seurat)
library(randomForest)
library(kernlab)
library(RSNNS)
library(caret)
library(ROCR)
library(pROC)
library(ggplot2)
library(dplyr)
library(tidyr)

## set seed
set.seed(1234)

## data
### models
svm_model <- readRDS("/path/to/sex_prediction_model/data/models/svm_rad_model.RDS")
rf_model <- readRDS("/path/to/sex_prediction_model/data/models/rf_model.RDS")
mlp_model <- readRDS("/path/to/sex_prediction_model/data/models/mlpwdml_model.RDS")
lr_model <- readRDS("/path/to/sex_prediction_model/data/models/lr_model.RDS")
chrY_model <- read.csv("/path/to/sex_prediction_model/output/Yclass.predictions.csv", row.names = 1)
Xist_model <- read.csv("/path/to/sex_prediction_model/output/Xist.class.predictions.csv", row.names = 1)

### testing data
Rn7_VTA_testing <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA_testing.RDS")
testing <- read.csv("/path/to/sex_prediction_model/data/test_count_data.csv", row.names = 1)
#### make character ID bin
testing$Identity_bin_char <- recode(testing$Identity_bin, `0` = "Male", `1` = "Female")
testing$Identity_bin_char <- factor(testing$Identity_bin_char, levels = c("Male", "Female"))
#### make ID bin a factor
testing$Identity_bin <- as.factor(testing$Identity_bin)
#### make cell type column
testing$CellType <- Rn7_VTA_testing@meta.data$CellType


# Make predictions ####
## probabilities
### logistic regression
lr_prediction <- predict(lr_model,testing[,1:285], type = "response")
### support vector machine
svm_prediction <- predict(svm_model,testing[,1:285], type = "prob")
### random forrest
rf_prediction <- predict(rf_model,testing[,1:285], type = "prob")
### multi-layer perceptron
mlp_prediction <- predict(mlp_model,testing[,1:285], type = "prob")
### chrY expression based prediction
chrY_prediction <- chrY_model$y.counts
### Xist expression based prediction
Xist_prediction <- Xist_model$Xist.counts

## classify with thresholds
### support vector machine
svm_prediction$class <- ifelse(svm_prediction$Female >0.5, "Female", "Male")
svm_prediction$class <- factor(svm_prediction$class, levels = c("Male", "Female"))
### random forrest
rf_prediction$class <- ifelse(rf_prediction$Female >0.5, "Female", "Male")
rf_prediction$class <- factor(rf_prediction$class, levels = c("Male", "Female"))
### multi-layer perceptron
mlp_prediction$class <- ifelse(mlp_prediction$Female >0.5, "Female", "Male")
mlp_prediction$class <- factor(mlp_prediction$class, levels = c("Male", "Female"))
### logistic regression
lr_prediction <- ifelse(lr_prediction >0.5, 1, 0)
lr_prediction <- as.factor(lr_prediction)
### chrY expression based prediction
chrY_prediction <- factor(chrY_model$Sex.prediction, levels = c("Male", "Female"))
### Xist expression based prediction
Xist_prediction <- factor(Xist_model$Sex.prediction, levels = c("Male", "Female"))


# Create data frame for evaluation ####
eval.df <- data.frame(CellType = testing$CellType,
                      Identity_bin = testing$Identity_bin,
                      Identity_bin_char  = testing$Identity_bin_char,
                      chrY_prediction = chrY_prediction,
                      Xist_prediction = Xist_prediction,
                      lr_prediction = lr_prediction,
                      svm_prediction = svm_prediction$class,
                      rf_prediction = rf_prediction$class,
                      mlp_prediction = mlp_prediction$class)
eval.df <- eval.df %>% mutate(Neuronal_Glial = case_when(CellType %in% c("Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3", "DA-Neuron") ~ "Neuronal",
                                                         CellType %in% c("Olig-1", "Olig-2", "Olig-3", "Astrocyte", "Polydendrocyte", "Microglia", "OPC-Olig-1", "Mural", "Endothelial") ~ "Glial"))
eval.df.split.celltype <- split(eval.df, f = eval.df$CellType)
eval.df.split.neuronal.glial <- split(eval.df, f = eval.df$Neuronal_Glial)

# Accuracy ####
## Neuronal and Glial cells separately
neuronal.glial.acc <- lapply(eval.df.split.neuronal.glial %>% names(), function(celltype){
  chrY_confusion <- confusionMatrix(eval.df.split.neuronal.glial[[celltype]][["chrY_prediction"]], eval.df.split.neuronal.glial[[celltype]][["Identity_bin_char"]])
  Xist_confusion <- confusionMatrix(eval.df.split.neuronal.glial[[celltype]][["Xist_prediction"]], eval.df.split.neuronal.glial[[celltype]][["Identity_bin_char"]])
  lr_confusion <- confusionMatrix(eval.df.split.neuronal.glial[[celltype]][["lr_prediction"]], eval.df.split.neuronal.glial[[celltype]][["Identity_bin"]])
  svm_confusion <- confusionMatrix(eval.df.split.neuronal.glial[[celltype]][["svm_prediction"]], eval.df.split.neuronal.glial[[celltype]][["Identity_bin_char"]])
  rf_confusion <- confusionMatrix(eval.df.split.neuronal.glial[[celltype]][["rf_prediction"]], eval.df.split.neuronal.glial[[celltype]][["Identity_bin_char"]])
  mlp_confusion <- confusionMatrix(eval.df.split.neuronal.glial[[celltype]][["mlp_prediction"]], eval.df.split.neuronal.glial[[celltype]][["Identity_bin_char"]])
  
  
  ## accuracy table
  acc.table <- data.frame(Accuracy = c(chrY_confusion[["overall"]][["Accuracy"]],
                                       Xist_confusion[["overall"]][["Accuracy"]],
                                       lr_confusion[["overall"]][["Accuracy"]],
                                       svm_confusion[["overall"]][["Accuracy"]],
                                       rf_confusion[["overall"]][["Accuracy"]],
                                       mlp_confusion[["overall"]][["Accuracy"]]))
  rownames(acc.table) <- c("Chr Y", "Xist","Logistic Regression", "SVM", "Random Forest", "MLP")
  
  
  ## stacked bar plot of prediction accuracies
  ### make list of confusion matrices
  confusion.list <- list(ChrY = chrY_confusion,
                         Xist = Xist_confusion,
                         `Logistic Regression` = lr_confusion,
                         SVM = svm_confusion,
                         `Random Forest` = rf_confusion,
                         MLP = mlp_confusion)
  
  ### extract values to data frame with values for reference_prediction
  confusion.df <- data.frame(model = c("Chr Y","Xist", "Logistic Regression", "SVM", "Random Forest", "MLP"),
                             Male_correct = lapply(confusion.list, function(x){x[["table"]][1,1]}) %>% unlist(),
                             Female_incorrect = lapply(confusion.list, function(x){x[["table"]][1,2]}) %>% unlist(),
                             Male_incorrect = lapply(confusion.list, function(x){x[["table"]][2,1]}) %>% unlist(),
                             Female_correct = lapply(confusion.list, function(x){x[["table"]][2,2]}) %>% unlist())
  
  ### convert to long format and split reference level and prediction
  confusion.df.long <- confusion.df %>%
    pivot_longer(cols = Male_correct:Female_correct,
                 names_to = "prediction",
                 values_to = "count") %>%
    separate(col = prediction,
             into = c("reference","prediction"),
             sep = "_")
  
  ### convert variables to factors
  confusion.df.long <- confusion.df.long %>% mutate(reference = factor(reference, levels = c("Male", "Female")),
                                                    prediction = factor(prediction, levels = c("incorrect","correct")),
                                                    model = factor(model, levels = rev(c("Chr Y","Xist", "Logistic Regression", "SVM", "Random Forest", "MLP"))))
  
  ### create stacked bar plot of predictions split by sex
  confusion.plot <- ggplot(data = confusion.df.long, mapping = aes(x=model, y=count, fill=prediction)) + 
    geom_bar(position="fill", stat="identity") +
    facet_wrap( ~ reference) +
    theme_bw() +
    coord_flip() +
    labs(title = paste0("Confuson plot: ", celltype), x = "Model", y = "Proportion") +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
  
  ### save
  ggsave(plot = confusion.plot,
         file = paste0("/path/to/sex_prediction_model/output/confusionplot.", celltype,".pdf"),
         height = 7,
         width = 10,
         device = "pdf")
  
  # return table
  return(acc.table)
})

names(neuronal.glial.acc) <- names(eval.df.split.neuronal.glial)
#### merge to dataframe 
neuronal.glial.acc.df <- bind_cols(neuronal.glial.acc)
colnames(neuronal.glial.acc.df) <- names(eval.df.split.neuronal.glial)

### Cell Types separately
celltype.acc <- lapply(eval.df.split.celltype %>% names(), function(celltype){
  chrY_confusion <- confusionMatrix(eval.df.split.celltype[[celltype]][["chrY_prediction"]], eval.df.split.celltype[[celltype]][["Identity_bin_char"]])
  Xist_confusion <- confusionMatrix(eval.df.split.celltype[[celltype]][["Xist_prediction"]], eval.df.split.celltype[[celltype]][["Identity_bin_char"]])
  lr_confusion <- confusionMatrix(eval.df.split.celltype[[celltype]][["lr_prediction"]], eval.df.split.celltype[[celltype]][["Identity_bin"]])
  svm_confusion <- confusionMatrix(eval.df.split.celltype[[celltype]][["svm_prediction"]], eval.df.split.celltype[[celltype]][["Identity_bin_char"]])
  rf_confusion <- confusionMatrix(eval.df.split.celltype[[celltype]][["rf_prediction"]], eval.df.split.celltype[[celltype]][["Identity_bin_char"]])
  mlp_confusion <- confusionMatrix(eval.df.split.celltype[[celltype]][["mlp_prediction"]], eval.df.split.celltype[[celltype]][["Identity_bin_char"]])
  
  ## Accuracy table
  acc.table <- data.frame(Accuracy = c(chrY_confusion[["overall"]][["Accuracy"]],
                                       Xist_confusion[["overall"]][["Accuracy"]],
                                       lr_confusion[["overall"]][["Accuracy"]],
                                       svm_confusion[["overall"]][["Accuracy"]],
                                       rf_confusion[["overall"]][["Accuracy"]],
                                       mlp_confusion[["overall"]][["Accuracy"]]))
  rownames(acc.table) <- c("Chr Y", "Xist","Logistic Regression", "SVM", "Random Forest", "MLP")
  
  
  ## stacked bar plot of prediction accuracies
  ### make list of confusion matrices
  confusion.list <- list(ChrY = chrY_confusion,
                         Xist = Xist_confusion,
                         `Logistic Regression` = lr_confusion,
                         SVM = svm_confusion,
                         `Random Forest` = rf_confusion,
                         MLP = mlp_confusion)
  
  ### extract values to data frame with values for reference_prediction
  confusion.df <- data.frame(model = c("Chr Y","Xist", "Logistic Regression", "SVM", "Random Forest", "MLP"),
                             Male_correct = lapply(confusion.list, function(x){x[["table"]][1,1]}) %>% unlist(),
                             Female_incorrect = lapply(confusion.list, function(x){x[["table"]][1,2]}) %>% unlist(),
                             Male_incorrect = lapply(confusion.list, function(x){x[["table"]][2,1]}) %>% unlist(),
                             Female_correct = lapply(confusion.list, function(x){x[["table"]][2,2]}) %>% unlist())
  
  ### convert to long format and split reference level and prediction
  confusion.df.long <- confusion.df %>%
    pivot_longer(cols = Male_correct:Female_correct,
                 names_to = "prediction",
                 values_to = "count") %>%
    separate(col = prediction,
             into = c("reference","prediction"),
             sep = "_")
  
  ### convert variables to factors
  confusion.df.long <- confusion.df.long %>% mutate(reference = factor(reference, levels = c("Male", "Female")),
                                                    prediction = factor(prediction, levels = c("incorrect","correct")),
                                                    model = factor(model, levels = rev(c("Chr Y","Xist", "Logistic Regression", "SVM", "Random Forest", "MLP"))))
  
  ### create stacked bar plot of predictions split by sex
  confusion.plot <- ggplot(data = confusion.df.long, mapping = aes(x=model, y=count, fill=prediction)) + 
    geom_bar(position="fill", stat="identity") +
    facet_wrap( ~ reference) +
    theme_bw() +
    coord_flip() +
    labs(title = paste0("Confuson plot: ", celltype), x = "Model", y = "Proportion") +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
  
  ### save
  ggsave(plot = confusion.plot,
         file = paste0("/path/to/sex_prediction_model/output/confusionplot.", celltype,".pdf"),
         height = 7,
         width = 10,
         device = "pdf")
  
  
  
  return(acc.table)
})

names(celltype.acc) <- names(eval.df.split.celltype)
#### merge to dataframe
celltype.acc.df <- bind_cols(celltype.acc)
colnames(celltype.acc.df) <- names(eval.df.split.celltype)
#### change column order to be neurons -> glia
celltype.acc.df <- celltype.acc.df %>% select("DA-Neuron", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3", "Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "Olig-1", "Olig-2", "Olig-3", "OPC-Olig-1", "Polydendrocyte", "Astrocyte", "Microglia", "Mural", "Endothelial")


# ROC + AUC ####
## Remake overall table with probabilities
roc.eval.df <- data.frame(CellType = testing$CellType,
                          Identity_bin = testing$Identity_bin,
                          Identity_bin_char  = testing$Identity_bin_char,
                          chrY_prediction = chrY_model$y.counts,
                          Xist_prediction = Xist_model$Xist.counts,
                          lr_prediction = predict(lr_model,testing[,1:285], type = "response"),
                          svm_prediction = svm_prediction[,2],
                          rf_prediction = rf_prediction[,2],
                          mlp_prediction = mlp_prediction[,2])
roc.eval.df <- roc.eval.df %>% mutate(Neuronal_Glial = case_when(CellType %in% c("Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3", "DA-Neuron") ~ "Neuronal",
                                                                 CellType %in% c("Olig-1", "Olig-2", "Olig-3", "Astrocyte", "Polydendrocyte", "Microglia", "OPC-Olig-1", "Mural", "Endothelial") ~ "Glial"))
roc.eval.df.split.celltype <- split(roc.eval.df, f = roc.eval.df$CellType) # table split by individual cell type
roc.eval.df.split.neuronal.glial <- split(roc.eval.df, f = roc.eval.df$Neuronal_Glial) # table split by neuronal and glial cell types

## Neuronal and glial cell types separately
neuronal.glial.auc <- lapply(roc.eval.df.split.neuronal.glial %>% names(), function(celltype){
  ## calculate ROC
  Xist_roc <- roc(roc.eval.df.split.neuronal.glial[[celltype]][["Identity_bin_char"]],roc.eval.df.split.neuronal.glial[[celltype]][["Xist_prediction"]], levels = c("Female", "Male"), direction = ">")
  chrY_roc <- roc(roc.eval.df.split.neuronal.glial[[celltype]][["Identity_bin_char"]],roc.eval.df.split.neuronal.glial[[celltype]][["chrY_prediction"]], levels = c("Female", "Male"))
  lr_roc <- roc(roc.eval.df.split.neuronal.glial[[celltype]][["Identity_bin"]],roc.eval.df.split.neuronal.glial[[celltype]][["lr_prediction"]], levels = c(1,0))
  svm_roc <- roc(roc.eval.df.split.neuronal.glial[[celltype]][["Identity_bin_char"]],roc.eval.df.split.neuronal.glial[[celltype]][["svm_prediction"]], levels = c("Female", "Male"))
  rf_roc <- roc(roc.eval.df.split.neuronal.glial[[celltype]][["Identity_bin_char"]],roc.eval.df.split.neuronal.glial[[celltype]][["rf_prediction"]], levels = c("Female", "Male"))
  mlp_roc <- roc(roc.eval.df.split.neuronal.glial[[celltype]][["Identity_bin_char"]],roc.eval.df.split.neuronal.glial[[celltype]][["mlp_prediction"]], levels = c("Female", "Male"))
  
  ## ROC curve
  g <- ggroc(data = list(`Chr Y` = chrY_roc,
                         `Xist` = Xist_roc,
                         `Logistic Regression` = lr_roc,
                         `SVM` = svm_roc,
                         `Random Forest` = rf_roc,
                         `MLP` = mlp_roc)) +
    geom_abline(slope = 1, intercept = 1, linetype = "dashed") +
    labs(color = "Model", title = celltype) +
    theme_bw()
  
  ggsave(filename = paste0("/path/to/sex_prediction_model/output/ROC_", celltype,"_curves.pdf"),
         plot = g + theme(text = element_text(size = 20)),
         height = 10,
         width = 12,
         device = "pdf")
  
  ## AUC table
  auc.table <- data.frame(AUC = c(chrY_roc[["auc"]] %>% as.numeric(),
                                  Xist_roc[["auc"]] %>% as.numeric(),
                                  lr_roc[["auc"]] %>% as.numeric(),
                                  svm_roc[["auc"]] %>% as.numeric(),
                                  rf_roc[["auc"]] %>% as.numeric(),
                                  mlp_roc[["auc"]] %>% as.numeric()))
  rownames(auc.table) <- c("Chr Y", "Xist", "Logistic Regression","SVM", "Random Forest", "MLP")
  return(auc.table)
})
names(neuronal.glial.auc) <- names(roc.eval.df.split.neuronal.glial)
### merge to dataframe 
neuronal.glial.auc.df <- bind_cols(neuronal.glial.auc)
colnames(neuronal.glial.auc.df) <- names(roc.eval.df.split.neuronal.glial)



## Cell types separately
celltype.auc <- lapply(roc.eval.df.split.celltype %>% names(), function(celltype){
  ## calculate ROC
  ## calculate ROC
  Xist_roc <- roc(roc.eval.df.split.celltype[[celltype]][["Identity_bin_char"]],roc.eval.df.split.celltype[[celltype]][["Xist_prediction"]], levels = c("Female", "Male"), direction = ">")
  chrY_roc <- roc(roc.eval.df.split.celltype[[celltype]][["Identity_bin_char"]],roc.eval.df.split.celltype[[celltype]][["chrY_prediction"]], levels = c("Female", "Male"))
  lr_roc <- roc(roc.eval.df.split.celltype[[celltype]][["Identity_bin"]],roc.eval.df.split.celltype[[celltype]][["lr_prediction"]], levels = c(1,0))
  svm_roc <- roc(roc.eval.df.split.celltype[[celltype]][["Identity_bin_char"]],roc.eval.df.split.celltype[[celltype]][["svm_prediction"]], levels = c("Female", "Male"))
  rf_roc <- roc(roc.eval.df.split.celltype[[celltype]][["Identity_bin_char"]],roc.eval.df.split.celltype[[celltype]][["rf_prediction"]], levels = c("Female", "Male"))
  mlp_roc <- roc(roc.eval.df.split.celltype[[celltype]][["Identity_bin_char"]],roc.eval.df.split.celltype[[celltype]][["mlp_prediction"]], levels = c("Female", "Male"))
  
  ## ROC curve
  g <- ggroc(data = list(`Chr Y` = chrY_roc,
                         `Xist` = Xist_roc,
                         `Logistic Regression` = lr_roc,
                         `SVM` = svm_roc,
                         `Random Forest` = rf_roc,
                         `MLP` = mlp_roc)) +
    geom_abline(slope = 1, intercept = 1, linetype = "dashed") +
    labs(color = "Model", title = celltype) +
    theme_bw()
  
  ggsave(filename = paste0("/path/to/sex_prediction_model/output/ROC_", celltype,"_curves.pdf"),
         plot = g + theme(text = element_text(size = 20)),
         height = 10,
         width = 12,
         device = "pdf")
  
  ## AUC table
  auc.table <- data.frame(AUC = c(chrY_roc[["auc"]] %>% as.numeric(),
                                  Xist_roc[["auc"]] %>% as.numeric(),
                                  lr_roc[["auc"]] %>% as.numeric(),
                                  svm_roc[["auc"]] %>% as.numeric(),
                                  rf_roc[["auc"]] %>% as.numeric(),
                                  mlp_roc[["auc"]] %>% as.numeric()))
  rownames(auc.table) <- c("Chr Y", "Xist", "Logistic Regression","SVM", "Random Forest", "MLP")
  return(auc.table)
})
names(celltype.auc) <- names(roc.eval.df.split.celltype)
### merge to dataframe
celltype.auc.df <- bind_cols(celltype.auc)
colnames(celltype.auc.df) <- names(roc.eval.df.split.celltype)
### change column order to be neurons -> glia
celltype.auc.df <- celltype.auc.df %>% select("DA-Neuron", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3", "Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "Olig-1", "Olig-2", "Olig-3", "OPC-Olig-1", "Polydendrocyte", "Astrocyte", "Microglia", "Mural", "Endothelial")


# Write out results ####
write.csv(celltype.auc.df, file = "/path/to/sex_prediction_model/output/AUCs_celltype_table.csv")
write.csv(neuronal.glial.auc.df, file = "/path/to/sex_prediction_model/output/AUCs_neuronal_glial_table.csv")
write.csv(celltype.acc.df, file = "/path/to/sex_prediction_model/output/Accuracy_celltype_table.csv")
write.csv(neuronal.glial.acc.df, file = "/path/to/sex_prediction_model/output/Accuracy_neuronal_glial_table.csv")


# Session Info ####
sessionInfo()
```

```{bash filename="celltype_split_performance_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=celltype_split_performance
#SBATCH --output=/path/to/sex_prediction_model/logs/celltype_split_performance_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/celltype_split_performance_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/celltype_split_performance.R
```


### Prediction Thresholding
Models predict cell sex probabilities form 0 (likely male) to 1 (likely female), enabling us to refine our overall accuracy by omitting tenuous predictions near the clasification threshold of 0.5. To assess the number of cells omitted and improvements to accuracy for different thresholds, we evaluated two thresholds centered around 0.5: narrow (0.4-0.6) and wide (0.25-0.75). To apply these thresholds, we make classifications with the LR model as usual and simply count the number of cells falling inside/outside each threshold as well as the accuracy of predicitons inside/outside each threshold.

```{r filename="lr_test_thresholding.R"}
# Setup ####
## Libraries
library(SeuratObject)
library(Seurat)
library(caret)
library(ROCR)
library(pROC)
library(ggplot2)
library(dplyr)
library(tidyr)
library(magrittr)

## Data ####
### testing data
Rn7_VTA_testing <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA_testing.RDS")
testing <- read.csv("/path/to/sex_prediction_model/data/test_count_data.csv", row.names = 1)
#### make character ID bin
testing$Identity_bin_char <- recode(testing$Identity_bin, `0` = "Male", `1` = "Female")
testing$Identity_bin_char <- factor(testing$Identity_bin_char, levels = c("Male", "Female"))
#### make ID bin a factor
testing$Identity_bin <- as.factor(testing$Identity_bin)
#### make cell type column
testing$CellType <- Rn7_VTA_testing@meta.data$CellType

### logistic regression model
lr_model <- readRDS("/path/to/sex_prediction_model/data/models/lr_model.RDS")

# Make test data set predictions ####
lr_prediction <- predict(lr_model,testing[,1:285], type = "response")
lr_prediction_df <- data.frame(cell = names(lr_prediction),
                               prediction = lr_prediction,
                               binarized = ifelse(lr_prediction >0.5, 1, 0),
                               character = ifelse(lr_prediction >0.5, "Female", "Male") %>% as.factor(),
                               real = (as.numeric(testing$Identity_bin)-1),
                               celltype = testing$CellType,
                               GEM_Well = Rn7_VTA_testing$GEM_Well)
lr_prediction_df <- lr_prediction_df %>% 
  mutate(correct = binarized == real)

# Evaluate prediction thresholds using test data ####
thresholding_stats_df <- data.frame(threshold = c(0,0.1, 0.25),
           ncell_included = c(nrow(lr_prediction_df),
                              lr_prediction_df %>% filter(prediction < 0.4 | prediction > 0.6) %>% nrow(),
                              lr_prediction_df %>% filter(prediction < 0.25 | prediction > 0.75) %>% nrow()),
           ncell_excluded = c(0,
                              nrow(lr_prediction_df) - lr_prediction_df %>% filter(prediction < 0.4 | prediction > 0.6) %>% nrow(),
                              nrow(lr_prediction_df) - lr_prediction_df %>% filter(prediction < 0.25 | prediction > 0.75) %>% nrow()),
           nfemale_included = c(lr_prediction_df %>% pull(real) %>% sum(),
                                lr_prediction_df %>% filter(prediction < 0.4 | prediction > 0.6) %>% pull(real) %>% sum(),
                                lr_prediction_df %>% filter(prediction < 0.25 | prediction > 0.75) %>% pull(real) %>% sum()),
           nfemale_excluded = c(0,
                                lr_prediction_df %>% filter(prediction > 0.4 & prediction < 0.6) %>% pull(real) %>% sum(),
                                lr_prediction_df %>% filter(prediction > 0.25 & prediction < 0.75) %>% pull(real) %>% sum()),
           acc_included = c(lr_prediction_df %>%
                              pull(correct) %>%
                              sum() / lr_prediction_df %>% nrow(),
                            lr_prediction_df %>%
                              filter(prediction < 0.4 | prediction > 0.6) %>%
                              pull(correct) %>% sum() / lr_prediction_df %>% filter(prediction < 0.4 | prediction > 0.6) %>% nrow(),
                            lr_prediction_df %>%
                              filter(prediction < 0.25 | prediction > 0.75) %>%
                              pull(correct) %>% sum() / lr_prediction_df %>% filter(prediction < 0.25 | prediction > 0.75) %>% nrow()),
           acc_excluded = c(NA,
                            lr_prediction_df %>%
                              filter(prediction > 0.4 & prediction < 0.6) %>%
                              pull(correct) %>% sum() / lr_prediction_df %>% filter(prediction > 0.4 & prediction < 0.6) %>% nrow(),
                            lr_prediction_df %>%
                              filter(prediction > 0.25 & prediction < 0.75) %>%
                              pull(correct) %>% sum() / lr_prediction_df %>% filter(prediction > 0.25 & prediction < 0.75) %>% nrow())
           )

## Plot test data class prediction distribution
test.hist <- ggplot(data = lr_prediction_df, aes(x = prediction)) +
  geom_histogram(binwidth = 0.05, fill = "grey") +
  ylim(c(0,3800)) +
  labs(title = "Test Data: Class Prediction Probabilities (bin size = 5)",
       x = "probability",
       y = "count") +
  theme_bw()

## Plot test data class predicitons with thresholds
test.hist.threshold <- ggplot(data = lr_prediction_df, aes(x = prediction)) +
  geom_histogram(binwidth = 0.05, fill = "grey") +
  ylim(c(0,3800)) +
  geom_vline(xintercept = 0.25, color = "red", linetype = "dotted") +
  geom_vline(xintercept = 0.75, color = "red", linetype = "dotted") +
  geom_vline(xintercept = 0.4, color = "blue", linetype = "dotted") +
  geom_vline(xintercept = 0.6, color = "blue", linetype = "dotted") +
  labs(title = "Test Data: Class Prediction Probabilities (bin size = 5)",
       x = "probability",
       y = "count") +
  theme_bw()

### plot distribution of false classifications
test_false.hist.threshold <- lr_prediction_df %>% filter(correct == F) %>% 
  ggplot(aes(x = prediction)) +
    geom_histogram(binwidth = 0.05, fill = "grey") +
    ylim(c(0,3800)) +
    geom_vline(xintercept = 0.25, color = "red", linetype = "dotted") +
    geom_vline(xintercept = 0.75, color = "red", linetype = "dotted") +
    geom_vline(xintercept = 0.4, color = "blue", linetype = "dotted") +
    geom_vline(xintercept = 0.6, color = "blue", linetype = "dotted") +
    labs(title = "Test Data: Class Prediction Probabilities (bin size = 5)",
         x = "probability",
         y = "count") +
    theme_bw()

test_false.hist.threshold.scaled <- lr_prediction_df %>% filter(correct == F) %>% 
  ggplot(aes(x = prediction)) +
  geom_histogram(binwidth = 0.05, fill = "grey") +
  #ylim(c(0,3800)) +
  geom_vline(xintercept = 0.25, color = "red", linetype = "dotted") +
  geom_vline(xintercept = 0.75, color = "red", linetype = "dotted") +
  geom_vline(xintercept = 0.4, color = "blue", linetype = "dotted") +
  geom_vline(xintercept = 0.6, color = "blue", linetype = "dotted") +
  labs(title = "Test Data: Class Prediction Probabilities (bin size = 5)",
       x = "probability",
       y = "count") +
  theme_bw()

## Plot test data class binarized predicitons
test.hist.binarized <- ggplot(data = lr_prediction_df, aes(x = binarized)) +
  geom_histogram(binwidth = 0.05, fill = "grey") +
  ylim(c(0,3800)) +
  labs(title = "Test Data: Class Prediction binarized (bin size = 5)",
       x = "probability",
       y = "count") +
  theme_bw()

test.hist.true <- ggplot(data = lr_prediction_df, aes(x = (as.numeric(real)-1))) +
  geom_histogram(binwidth = 0.05, fill = "grey") +
  ylim(c(0,3800)) +
  labs(title = "Test Data: True Class Identities (bin size = 5)",
       x = "probability",
       y = "count") +
  theme_bw()

## Affected cell types
### Test data
test_celltypes <- table(testing$CellType) %>% data.frame()
test_celltypes <- test_celltypes %>% 
  mutate(exclude.10 = lr_prediction_df %>% 
           filter(prediction > 0.4 & prediction < 0.6) %$% 
           table(.$celltype) %>% data.frame() %>% pull(Freq),
         exclude.25 = lr_prediction_df %>% 
           filter(prediction > 0.25 & prediction < 0.75) %$% 
           table(.$celltype) %>% data.frame() %>% pull(Freq))

# Save output ####
## accuracy w/ different thresholds
write.csv(thresholding_stats_df, file = "/path/to/sex_prediction_model/output/thresholding/LR_threshold_stats.csv")
## ncells per cell type excluded by decision buffer
write.csv(test_celltypes, file = "/path/to/sex_prediction_model/output/thresholding/LR_test_ncells.csv")

## test data predicted probability distribution w/o thresholds
ggsave(plot = test.hist,
       filename = "/path/to/sex_prediction_model/output/thresholding/LR_test_prediction_hist.pdf",
       device = "pdf",
       height = 3,
       width = 5)

## test data predicted probability distribution w/ thresholds
ggsave(plot = test.hist.threshold,
       filename = "/path/to/sex_prediction_model/output/thresholding/LR_test_prediction_threshold_hist.pdf",
       device = "pdf",
       height = 3,
       width = 5)

## test data false predictions distribution w/ threshold unscaled
ggsave(plot = test_false.hist.threshold,
       filename = "/path/to/sex_prediction_model/output/thresholding/LR_test_prediction_false_hist.pdf",
       device = "pdf",
       height = 3,
       width = 5)

## test data false predictions distribution w/ threshold scaled
ggsave(plot = test_false.hist.threshold.scaled,
       filename = "/path/to/sex_prediction_model/output/thresholding/LR_test_prediction_false_hist_scaled.pdf",
       device = "pdf",
       height = 3,
       width = 5)

## test data predicted probability distribution binarized
ggsave(plot = test.hist.binarized,
       filename = "/path/to/sex_prediction_model/output/thresholding/LR_test_prediction_binarized_hist.pdf",
       device = "pdf",
       height = 3,
       width = 5)

## test data predicted probability distribution true vals
ggsave(plot = test.hist.true,
       filename = "/path/to/sex_prediction_model/output/thresholding/LR_test_prediction_true_hist.pdf",
       device = "pdf",
       height = 3,
       width = 5)

# Session info ####
sessionInfo()
```

```{bash filename="lr_test_thresholding_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=lr_test_prediction_threshold
#SBATCH --output=/path/to/sex_prediction_model/logs/lr_test_prediction_threshold_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/lr_test_prediction_threshold_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/lr_test_thresholding.R
```


### UMI count vs Accuracy
To determine if the UMI count (unique molecular index) per cell was associated with model accuracy, we used logistic regression analysis. Logistic regression models were fit for VTA test partition cell UMI count and model classification accuracy (correct: 1, incorrect: 0) for all sex prediction models. The fit models were used to determine the UMI count at which the probability of a correct model classification reached 95%.

```{r filename="UMI_vs_correct.R"}
# Setup ####
## libraries
library(Seurat)
library(caret)
library(randomForest)
library(kernlab)
library(RSNNS)
library(ROCR)
library(pROC)
library(ggplot2)
library(dplyr)
library(tidyr)
library(patchwork)

## set seed
set.seed(1234)

## functions
### Chr Y classification
y.count <- function(srat.object){
  # load gene expression count data
  srat.counts <- as.data.frame(t(as.matrix(GetAssayData(object = srat.object, slot = "data", assay = "RNA"))))
  
  # load gene annotations
  Rn7.gtf <- rtracklayer::import("/path/to/sex_prediction_model/data/Rattus_norvegicus.mRatBN7.2.105.gtf")
  Rn7.gtf <- as.data.frame(Rn7.gtf)
  
  # select Y chromosome genes
  y.genes <- Rn7.gtf %>% #from Rn7 gene annotations
    filter(seqnames == "Y") %>% #filter for chrY only
    select(gene_id, gene_name) %>% #select gene ids and names
    mutate(gene_name = coalesce(gene_name, gene_id)) %>% #replace NA name values with gene ID
    pull(gene_name) %>% #pull gene name values
    unique() #only unique values, returns 27 genes
  
  # create cumulative expresion of Y genes
  y.counts <- srat.counts %>%
    select(any_of(y.genes)) %>%
    rowSums() %>% data.frame()
  ### set column name
  colnames(y.counts) <- c("y.counts")
  
  return(y.counts)
}
y.count.classify <- function(srat.object, threshold){
  srat.object$y.counts <- y.count(srat.object)
  classifications <- case_when(srat.object$y.counts > threshold ~ "Male",
                               TRUE ~ "Female")
  return(classifications)
}

### Xist classification
Xist.count <- function(srat.object){
  # load gene expression count data
  Xist.counts <- as.data.frame(t(as.matrix(GetAssayData(object = srat.object, slot = "data", assay = "RNA")))) %>%
    pull("ENSRNOG00000065796") # pull out Xist (named as ENSRNOG00000065796)
  
  return(Xist.counts)
}
Xist.count.classify <- function(srat.object, threshold){
  srat.object$Xist.counts <- Xist.count(srat.object)
  classifications <- case_when(srat.object$Xist.counts > threshold ~ "Female",
                               TRUE ~ "Male")
  return(classifications)
}

## data
### models
svm_model <- readRDS("/path/to/sex_prediction_model/data/models/svm_rad_model.RDS")
rf_model <- readRDS("/path/to/sex_prediction_model/data/models/rf_model.RDS")
mlp_model <- readRDS("/path/to/sex_prediction_model/data/models/mlpwdml_model.RDS")
lr_model <- readRDS("/path/to/sex_prediction_model/data/models/lr_model.RDS")
chrY_model <- read.csv("/path/to/sex_prediction_model/output/Yclass.predictions.csv", row.names = 1)
Xist_model <- read.csv("/path/to/sex_prediction_model/output/Xist.class.predictions.csv", row.names = 1)

### testing data
testing.VTA <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA_testing.RDS") #Seurat object
testing <- read.csv("/path/to/sex_prediction_model/data/test_count_data.csv", row.names = 1) #Read count table
#### make character ID bin
testing$Identity_bin_char <- recode(testing$Identity_bin, `0` = "Male", `1` = "Female")
testing$Identity_bin_char <- factor(testing$Identity_bin_char, levels = c("Male", "Female"))
#### make ID bin a factor
testing$Identity_bin <- as.factor(testing$Identity_bin)
#### add neuronal/nonneuronal celltype column
testing.VTA@meta.data <- testing.VTA@meta.data %>% 
  mutate(Neuronal = case_when(CellType %in% c("Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3", "DA-Neuron") ~ "Neuronal",
                                  CellType %in% c("Olig-1", "Olig-2", "Olig-3", "Astrocyte", "Polydendrocyte", "Microglia", "OPC-Olig-1", "Mural", "Endothelial") ~ "Non-Neuronal"))

# Predictions ####
## logistic regression
lr_prediction <- predict(lr_model,testing[,1:285], type = "response")
## support vector machine
svm_prediction <- predict(svm_model,testing[,1:285], type = "prob")
## random forrest
rf_prediction <- predict(rf_model,testing[,1:285], type = "prob")
## multi-layer perceptron
mlp_prediction <- predict(mlp_model,testing[,1:285], type = "prob")
## chrY expression based prediction
chrY_prediction <- data.frame(cell = names(Idents(testing.VTA)),
                              sex = testing.VTA$Sex,
                              counts = y.count(testing.VTA),
                              prediction = y.count.classify(testing.VTA,0))
chrY_prediction$prediction <- factor(chrY_prediction$prediction, levels = c("Male", "Female"))
## Xist expression based prediction
Xist_prediction <- data.frame(cell = names(Idents(testing.VTA)),
                              sex = testing.VTA$Sex,
                              counts = Xist.count(testing.VTA),
                              prediction = Xist.count.classify(testing.VTA,0))
Xist_prediction$prediction <- factor(Xist_prediction$prediction, levels = c("Male", "Female"))

## make precitions using threshold
svm_prediction$class <- ifelse(svm_prediction$Female >0.5, "Female", "Male")
svm_prediction$class <- factor(svm_prediction$class, levels = c("Male", "Female"))

rf_prediction$class <- ifelse(rf_prediction$Female >0.5, "Female", "Male")
rf_prediction$class <- factor(rf_prediction$class, levels = c("Male", "Female"))

mlp_prediction$class <- ifelse(mlp_prediction$Female >0.5, "Female", "Male")
mlp_prediction$class <- factor(mlp_prediction$class, levels = c("Male", "Female"))

lr_prediction <- ifelse(lr_prediction >0.5, "Female", "Male")
lr_prediction <- factor(lr_prediction, levels = c("Male", "Female"))

# Aggregate results ####
acc.depth.df <- data.frame(cell = row.names(testing),
                           celltype = testing.VTA$Neuronal,
                           RNA = testing.VTA$nCount_RNA,
                           sex = testing.VTA$Sex,
                           chrY = chrY_prediction$prediction,
                           Xist = Xist_prediction$prediction,
                           lr = lr_prediction,
                           svm = svm_prediction$class,
                           rf = rf_prediction$class,
                           mlp = mlp_prediction$class)

## change predictions to correct?(T/F)
acc.depth.df <- acc.depth.df %>% 
  mutate(chrY = case_when(chrY == sex ~ 1,
                          chrY != sex ~ 0),
         Xist = case_when(Xist == sex ~ 1,
                          Xist != sex ~ 0),
         lr   = case_when(lr == sex ~ 1,
                          lr != sex ~ 0),
         svm  = case_when(svm == sex ~ 1,
                          svm != sex ~ 0),
         rf   = case_when(rf == sex ~ 1,
                          rf != sex ~ 0),
         mlp  = case_when(mlp == sex ~ 1,
                          mlp != sex ~ 0))

# Plot accuracy depth ####
## calculate logistic regressions for read depth and classification
fits <- list(chrY = glm(chrY ~ RNA, data = acc.depth.df, family = "binomial"),
             Xist = glm(Xist ~ RNA, data = acc.depth.df, family = "binomial"),
             lr = glm(lr ~ RNA, data = acc.depth.df, family = "binomial"),
             svm = glm(svm ~ RNA, data = acc.depth.df, family = "binomial"),
             rf = glm(rf ~ RNA, data = acc.depth.df, family = "binomial"),
             mlp = glm(mlp ~ RNA, data = acc.depth.df, family = "binomial"))

## collect results in data frame
model.intercept <- sapply(fits, function(x){coef(summary(x))[1,]}) %>% t() %>% data.frame()
model.intercept$model <- row.names(model.intercept)
colnames(model.intercept) <- c("Intercept_Estimate", "Intercept_StdErr", "Intercept_Z", "Interpect_pval", "model")

model.RNA <- sapply(fits, function(x){coef(summary(x))[2,]}) %>% t() %>% data.frame()
model.RNA$model <- row.names(model.RNA)
colnames(model.RNA) <- c("RNA_Estimate", "RNA_StdErr", "RNA_Z", "RNA_pval", "model")

results.df <- left_join(x = model.intercept,
                        y = model.RNA,
                        by = "model" ) %>% 
  select(model, Intercept_Estimate, Intercept_StdErr, Intercept_Z, Interpect_pval, RNA_Estimate, RNA_StdErr, RNA_Z, RNA_pval)

## calculate read depth at which probability of correct prediction is 95%
critical <- lapply(fits, function(model){
  ### Given values
  intercept <- model[["coefficients"]][["(Intercept)"]]
  coef_RNA <- model[["coefficients"]][["RNA"]]
  target_probability <- 0.95
  
  ### Define the equation to solve
  equation <- function(RNA) {
    p <- 1 / (1 + exp(-(intercept + coef_RNA * RNA)))
    return(p - target_probability)
  }
  
  ### Use uniroot to find the RNA value
  result <- uniroot(equation, c(0, 80000))  # Adjust the range as needed
  
  ### The result contains the RNA value
  return(round(result$root))
})

## make plots
theme_set(theme_bw())
theme_update(panel.grid.minor = element_blank(),
             panel.grid.major = element_blank(),
             panel.border = element_rect(colour = "black"),
             text = element_text(size = 10),
             axis.title = element_text(size = 8),
             axis.text = element_text(size = 7))

plots <- list(
  chrY_plot = ggplot(data = acc.depth.df,
                     mapping = aes(x = RNA, y = chrY)) +
    geom_point(shape = 1) +
    geom_smooth(method = "glm",
                method.args = list(family = "binomial"), se = F) +
    geom_hline(yintercept =  0.95, linetype = "dashed", color = "red") +
    geom_vline(xintercept =  critical$chrY, linetype = "dashed", color = "red") +
    scale_x_continuous(breaks = c(0, critical$chrY, 20000, 40000, 60000, 80000), guide = guide_axis(n.dodge = 2)) +
    scale_y_continuous(breaks = c(0, 0.25, 0.5, 0.75, 0.95, 1)) +
    labs(title = "Chr Y", x = "RNA count", y = "Classification"),
  
  Xist_plot = ggplot(data = acc.depth.df,
                     mapping = aes(x = RNA, y = Xist)) +
    geom_point(shape = 1) +
    geom_smooth(method = "glm",
                method.args = list(family = "binomial"), se = F) +
    geom_hline(yintercept =  0.95, linetype = "dashed", color = "red") +
    geom_vline(xintercept =  critical$Xist, linetype = "dashed", color = "red") +
    scale_x_continuous(breaks = c(0, critical$Xist, 20000, 40000, 60000, 80000),guide = guide_axis(n.dodge = 2)) +
    scale_y_continuous(breaks = c(0, 0.25, 0.5, 0.75, 0.95, 1)) +
    labs(title = "Xist", x = "RNA count", y = "Classification"),
  
  lr_plot = ggplot(data = acc.depth.df,
                   mapping = aes(x = RNA, y = lr)) +
    geom_point(shape = 1) +
    geom_smooth(method = "glm",
                method.args = list(family = "binomial"), se = F) +
    geom_hline(yintercept =  0.95, linetype = "dashed", color = "red") +
    geom_vline(xintercept =  critical$lr, linetype = "dashed", color = "red") +
    scale_x_continuous(breaks = c(0, critical$lr, 20000, 40000, 60000, 80000), guide = guide_axis(n.dodge = 2)) +
    scale_y_continuous(breaks = c(0, 0.25, 0.5, 0.75, 0.95, 1)) +
    labs(title = "LR", x = "RNA count", y = "Classification"),
  
  svm_plot = ggplot(data = acc.depth.df,
                    mapping = aes(x = RNA, y = svm)) +
    geom_point(shape = 1) +
    geom_smooth(method = "glm",
                method.args = list(family = "binomial"), se = F) +
    geom_hline(yintercept =  0.95, linetype = "dashed", color = "red") +
    geom_vline(xintercept =  critical$svm, linetype = "dashed", color = "red") +
    scale_x_continuous(breaks = c(0, critical$svm, 20000, 40000, 60000, 80000), guide = guide_axis(n.dodge = 2)) +
    scale_y_continuous(breaks = c(0, 0.25, 0.5, 0.75, 0.95, 1)) +
    labs(title = "SVM", x = "RNA count", y = "Classification"),
  rf_plot = ggplot(data = acc.depth.df,
                   mapping = aes(x = RNA, y = rf)) +
    geom_point(shape = 1) +
    geom_smooth(method = "glm",
                method.args = list(family = "binomial"), se = F) +
    geom_hline(yintercept =  0.95, linetype = "dashed", color = "red") +
    geom_vline(xintercept =  critical$rf, linetype = "dashed", color = "red") +
    scale_x_continuous(breaks = c(0, critical$rf, 20000, 40000, 60000, 80000), guide = guide_axis(n.dodge = 2)) +
    scale_y_continuous(breaks = c(0, 0.25, 0.5, 0.75, 0.95, 1)) +
    labs(title = "RF", x = "RNA count", y = "Classification"),
  mlp_plot = ggplot(data = acc.depth.df,
                    mapping = aes(x = RNA, y = mlp)) +
    geom_point(shape = 1) +
    geom_smooth(method = "glm",
                method.args = list(family = "binomial"), se = F) +
    geom_hline(yintercept =  0.95, linetype = "dashed", color = "red") +
    geom_vline(xintercept =  critical$mlp, linetype = "dashed", color = "red") +
    scale_x_continuous(breaks = c(0, critical$mlp, 20000, 40000, 60000, 80000), guide = guide_axis(n.dodge = 2)) +
    scale_y_continuous(breaks = c(0, 0.25, 0.5, 0.75, 0.95, 1)) +
    labs(title = "MLP", x = "RNA count", y = "Classification"))

## Arrange plots into figure
figure <- plots$chrY_plot + plots$Xist_plot + plots$lr_plot + plots$svm_plot + plots$rf_plot + plots$mlp_plot +
  plot_layout(ncol = 2)

# log scaled ####
plots.log <- list(
  chrY_plot = ggplot(data = acc.depth.df,
                     mapping = aes(x = RNA, y = chrY)) +
    geom_point(shape = 1) +
    geom_smooth(method = "glm",
                formula = y ~ I(10^x),
                method.args = list(family = "binomial"),
                se = F) + 
    geom_hline(yintercept =  0.95, linetype = "dashed", color = "red") +
    geom_vline(xintercept =  critical$chrY, linetype = "dashed", color = "red") +
    scale_x_continuous(breaks = c(0, 500, 1000,  5000, critical$chrY, 10000, 50000),
                       trans = "log10", guide = guide_axis(n.dodge = 2)) +
    scale_y_continuous(breaks = c(0, 0.25, 0.5, 0.75, 0.95, 1)) +
    labs(title = "Chr Y", x = "RNA count", y = "Classification"),
  
  Xist_plot = ggplot(data = acc.depth.df,
                     mapping = aes(x = RNA, y = Xist)) +
    geom_point(shape = 1) +
    geom_smooth(method = "glm",
                formula = y ~ I(10^x),
                method.args = list(family = "binomial"),
                se = F) +
    geom_hline(yintercept =  0.95, linetype = "dashed", color = "red") +
    geom_vline(xintercept =  critical$Xist, linetype = "dashed", color = "red") +
    scale_x_continuous(breaks = c(0, 500, 1000,  5000, 10000, critical$Xist, 50000),
                       trans = "log10", guide = guide_axis(n.dodge = 2)) +
    scale_y_continuous(breaks = c(0, 0.25, 0.5, 0.75, 0.95, 1)) +
    labs(title = "Xist", x = "RNA count", y = "Classification"),
  lr_plot = ggplot(data = acc.depth.df,
                   mapping = aes(x = RNA, y = lr)) +
    geom_point(shape = 1) +
    geom_smooth(method = "glm",
                formula = y ~ I(10^x),
                method.args = list(family = "binomial"),
                se = F) +
    geom_hline(yintercept =  0.95, linetype = "dashed", color = "red") +
    geom_vline(xintercept =  critical$lr, linetype = "dashed", color = "red") +
    scale_x_continuous(breaks = c(0, 500, 1000,  5000, critical$lr, 10000, 50000),
                       trans = "log10", guide = guide_axis(n.dodge = 2)) +
    scale_y_continuous(breaks = c(0, 0.25, 0.5, 0.75, 0.95, 1)) +
    labs(title = "LR", x = "RNA count", y = "Classification"),
  svm_plot = ggplot(data = acc.depth.df,
                    mapping = aes(x = RNA, y = svm)) +
    geom_point(shape = 1) +
    geom_smooth(method = "glm",
                formula = y ~ I(10^x),
                method.args = list(family = "binomial"),
                se = F) +
    geom_hline(yintercept =  0.95, linetype = "dashed", color = "red") +
    geom_vline(xintercept =  critical$svm, linetype = "dashed", color = "red") +
    scale_x_continuous(breaks = c(0, 500, 1000,  5000, critical$svm, 10000, 50000),
                       trans = "log10", guide = guide_axis(n.dodge = 2)) +
    scale_y_continuous(breaks = c(0, 0.25, 0.5, 0.75, 0.95, 1)) +
    labs(title = "SVM", x = "RNA count", y = "Classification"),
  rf_plot = ggplot(data = acc.depth.df,
                   mapping = aes(x = RNA, y = rf)) +
    geom_point(shape = 1) +
    geom_smooth(method = "glm",
                formula = y ~ I(10^x),
                method.args = list(family = "binomial"),
                se = F) +
    geom_hline(yintercept =  0.95, linetype = "dashed", color = "red") +
    geom_vline(xintercept =  critical$rf, linetype = "dashed", color = "red") +
    scale_x_continuous(breaks = c(0, 500, 1000,  5000, critical$rf, 10000, 50000),
                       trans = "log10", guide = guide_axis(n.dodge = 2)) +
    scale_y_continuous(breaks = c(0, 0.25, 0.5, 0.75, 0.95, 1)) +
    labs(title = "RF", x = "RNA count", y = "Classification"),
  mlp_plot = ggplot(data = acc.depth.df,
                    mapping = aes(x = RNA, y = mlp)) +
    geom_point(shape = 1) +
    geom_smooth(method = "glm",
                formula = y ~ I(10^x),
                method.args = list(family = "binomial"),
                se = F) +
    geom_hline(yintercept =  0.95, linetype = "dashed", color = "red") +
    geom_vline(xintercept =  critical$mlp, linetype = "dashed", color = "red") +
    scale_x_continuous(breaks = c(0, 500, 1000,  5000, critical$mlp, 10000, 50000),
                       trans = "log10", guide = guide_axis(n.dodge = 2)) +
    scale_y_continuous(breaks = c(0, 0.25, 0.5, 0.75, 0.95, 1)) +
    labs(title = "MLP", x = "RNA count", y = "Classification"))

## Arrange plots into figure
figure.log <- plots.log$chrY_plot + plots.log$Xist_plot + plots.log$lr_plot + plots.log$svm_plot + plots.log$rf_plot + plots.log$mlp_plot +
  plot_layout(ncol = 2)


#Save outputs
# logistic regression estimates
write.csv(results.df,
          file = "/path/to/sex_prediction_model/output/depth_vs_acc/depth_vs_acc.celltype.coeff.csv",
          row.names = F)

## non-scaled
pdf(file = "/path/to/sex_prediction_model/output/depth_vs_acc/depth_vs_acc.VTA.allmodels.pdf",
    width = 8,
    height = 8)
figure
dev.off()

## log10 scaled
pdf(file = "/path/to/sex_prediction_model/output/depth_vs_acc/depth_vs_acc.log.VTA.allmodels.pdf",
    width = 8,
    height = 8)
figure.log
dev.off()

# sessionInfo ####
sessionInfo()
```

```{bash filename="UMI_vs_correect_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=UMI_vs_correect
#SBATCH --output=/path/to/sex_prediction_model/logs/UMI_vs_correect_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/UMI_vs_correect_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/UMI_vs_correect.R
```


## Neuronal and Non-Neuronal models
Given the observed disparity in performance of models in neuronal and non-neuronal cell populations, we sought to determine if cell type-specific models would improve performance over pan-cellular models. Before fitting cell type-specific models, the VTA training data partition was split into subsets for either neuronal (Glut-Neuron-1, Glut-Neuron-2, Glut-Neuron-3, GABA-Neuron-1, GABA-Neuron-2, GABA-Neuron-3, DA-Neuron)  or non-neuronal (Olig-1, Olig-2, Olig-3, Astrocyte, Polydendrocyte, Microglia, OPC-Olig-1, Mural, Endothelial) cell type groups. Feature selection with Boruta was repeated with significant DEGs within each cell type subset. LR, RF, SVM, and MLP models were fit as described above for neuronal and non-neuronal cell type subsets.


### Creating training and testing partitions
To train and evaluate cell type-specific models, we first defined our cell type-specific training and testing data partitions. The same training/testing partitions as pan-cellular models were used, however each was further partitioned to neuronal and non-neuronal sets. Because sex-dependent DEGs analyses was initially conducted within each cell type, it was unessecary to repeat this stage of feature selection. However, the results of DEG analysis did need to be partitioned based on their results within either partition.

```{r filename="create_splits_celltype.R"}
# Setup ####
## libraries
library(Seurat)
library(tidyverse)

## seed
set.seed(1234)

## data
### training
Rn7_VTA.training <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA_training.RDS")
### testing
Rn7_VTA.testing <- readRDS("/path/to/sex_prediction_model/data/Rn7_VTA_testing.RDS")
### previous DEG results
Sex_DEGs <- read.csv("/path/to/sex_prediction_model/data/DEGs_sex_cluster_VTA_sig.csv")
### GTF
# Rn7_gtf <- rtracklayer::import("/path/to/sex_prediction_model/data/Rattus_norvegicus.mRatBN7.2.105.gtf")
# Rn7_gtf <- as.data.frame(Rn7_gtf)


# pre-processing ####
## make neuronal and non-neuronal cell labels
Rn7_VTA.training@meta.data <- Rn7_VTA.training@meta.data %>%
  mutate(Neuronal = case_when(CellType %in% c("Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3", "DA-Neuron") ~ "Neuronal",
                              CellType %in% c("Olig-1", "Olig-2", "Olig-3", "Astrocyte", "Polydendrocyte", "Microglia", "OPC-Olig-1", "Mural", "Endothelial") ~ "Non-neuronal")) # make a new column to designate neuronal and non-neuronal
Rn7_VTA.training@meta.data <- Rn7_VTA.training@meta.data %>% 
  mutate(Neuronal = factor(Neuronal, levels = c("Neuronal", "Non-neuronal"))) # make cell type and neuronal/non-neuronal factors 

Rn7_VTA.testing@meta.data <- Rn7_VTA.testing@meta.data %>%
  mutate(Neuronal = case_when(CellType %in% c("Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3", "DA-Neuron") ~ "Neuronal",
                              CellType %in% c("Olig-1", "Olig-2", "Olig-3", "Astrocyte", "Polydendrocyte", "Microglia", "OPC-Olig-1", "Mural", "Endothelial") ~ "Non-neuronal")) # make a new column to designate neuronal and non-neuronal
Rn7_VTA.testing@meta.data <- Rn7_VTA.testing@meta.data %>% 
  mutate(Neuronal = factor(Neuronal, levels = c("Neuronal", "Non-neuronal"))) # make cell type and neuronal/non-neuronal factors 


# split DEG list by neuronal and non-neuronal cluster results ####
### neuronal
neuronal.degs <- Sex_DEGs %>%
  filter(Cluster %in% c("Glut-Neuron-1", "Glut-Neuron-2", "Glut-Neuron-3", "GABA-Neuron-1", "GABA-Neuron-2", "GABA-Neuron-3", "DA-Neuron")) %>% 
  pull(GeneName) %>% 
  unique() # 70 genes

### non-neuronal
nonneuronal.degs <- Sex_DEGs %>% filter(Cluster %in% c("Olig-1", "Olig-2", "Olig-3", "Astrocyte", "Polydendrocyte", "Microglia", "OPC-Olig-1", "Mural", "Endothelial")) %>% 
  pull(GeneName) %>% 
  unique() # 364 genes


# make subsets for cell type ####
## training
Rn7_VTA.training@active.ident <- Rn7_VTA.training$Neuronal
Rn7_VTA.training.neuronal <- subset(x = Rn7_VTA.training, idents = "Neuronal")
Rn7_VTA.training.nonneuronal <- subset(x = Rn7_VTA.training, idents = "Non-neuronal")

## testing
Rn7_VTA.testing@active.ident <- Rn7_VTA.testing$Neuronal
Rn7_VTA.testing.neuronal <- subset(x = Rn7_VTA.testing, idents = "Neuronal")
Rn7_VTA.testing.nonneuronal <- subset(x = Rn7_VTA.testing, idents = "Non-neuronal")

# make subsets of count data ####
## training 
### neuronal
#### First pull the count data
training.neuronal.count_data_Full <- as.data.frame(t(as.matrix(GetAssayData(object = Rn7_VTA.training.neuronal,slot = "data",assay = "RNA"))))
#### check if rownames are in same order as the identities vector 
all(names(Idents(Rn7_VTA.training.neuronal)) == rownames(training.neuronal.count_data_Full)) #TRUE 
#### Now just create a new column in the training.neuronal.count_data_Full for identity
training.neuronal.count_data_Full$Identity <- as.factor(Rn7_VTA.training.neuronal$Sex)
#### Convert identitity to binary code. 
training.neuronal.count_data_Full$Identity_bin <- ifelse(training.neuronal.count_data_Full$Identity  == "Female",
                                                         1, #Females are 1
                                                         0) #Males are 0
#### Create a subset of count data full containing all of the Sex_DEGs
training.neuronal.count_data_subset <- training.neuronal.count_data_Full[,c(neuronal.degs,"Identity_bin")]


### non-neuronal
#### First pull the count data
training.nonneuronal.count_data_Full <- as.data.frame(t(as.matrix(GetAssayData(object = Rn7_VTA.training.nonneuronal,slot = "data",assay = "RNA"))))
#### check if rownames are in same order as the identities vector 
all(names(Idents(Rn7_VTA.training.nonneuronal)) == rownames(training.nonneuronal.count_data_Full)) #TRUE 
#### Now just create a new column in the training.nonneuronal.count_data_Full for identity
training.nonneuronal.count_data_Full$Identity <- as.factor(Rn7_VTA.training.nonneuronal$Sex)
#### Convert identitity to binary code. 
training.nonneuronal.count_data_Full$Identity_bin <- ifelse(training.nonneuronal.count_data_Full$Identity  == "Female",
                                                            1, #Females are 1
                                                            0) #Males are 0
#### Create a subset of count data full containing all of the Sex_DEGs
training.nonneuronal.count_data_subset <- training.nonneuronal.count_data_Full[,c(nonneuronal.degs,"Identity_bin")]


# save outputs ####
## seurat objects
saveRDS(Rn7_VTA.training.neuronal, "/path/to/sex_prediction_model/data/celltype_models/Rn7_VTA_training_neuronal.RDS")
saveRDS(Rn7_VTA.training.nonneuronal, "/path/to/sex_prediction_model/data/celltype_models/Rn7_VTA_training_nonneuronal.RDS")

saveRDS(Rn7_VTA.testing.neuronal, "/path/to/sex_prediction_model/data/celltype_models/Rn7_VTA_testing_neuronal.RDS")
saveRDS(Rn7_VTA.testing.nonneuronal, "/path/to/sex_prediction_model/data/celltype_models/Rn7_VTA_testing_nonneuronal.RDS")

## count data subsets
saveRDS(training.neuronal.count_data_subset, "/path/to/sex_prediction_model/data/celltype_models/training_neuronal_count_subset.RDS")
saveRDS(training.nonneuronal.count_data_subset, "/path/to/sex_prediction_model/data/celltype_models/training_nonneuronal_count_subset.RDS")

# sessionInfo ####
sessionInfo()
```

```{bash filename="create_splits_celltype_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=create_splits
#SBATCH --output=/path/to/sex_prediction_model/logs/create_splits_celltype_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/create_splits_celltype_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/celltype_models/create_splits_celltype.R
```


### Feature selection
Boruta feature selection was conducted for each set of significant neuronal or non-neuronal DEGs, using the same parameters as in pan-cellular feature selection.


#### Neuronal
```{r filename="boruta_selection_neuronal.R"}
# Setup ####
## libraries
library(Boruta)
## seed
set.seed(1234)
## load data
count_data_subset <- readRDS("/path/to/sex_prediction_model/data/celltype_models/training_neuronal_count_subset.RDS")

# Feature selection ####
VTA_Boruta <- Boruta(Identity_bin ~ ., data = count_data_subset, maxRuns = 2000, doTrace = 2)

# Save output ####
saveRDS(VTA_Boruta,"/path/to/sex_prediction_model/data/celltype_models/VTA_Boruta_max2000_neuronal.RDS")

# Session info ####
sessionInfo()
```

```{bash filename="boruta_selection_neuronal_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=boruta_selection_neuronal
#SBATCH --output=/path/to/sex_prediction_model/logs/boruta_selection_neuronal_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/boruta_selection_neuronal_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=medium
#SBATCH --time=48:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/celltype_models/boruta_selection_neuronal.R
```


#### Non-neuronal
```{r filename="boruta_selection_nonneuronal.R"}
# Setup ####
## libraries
library(Boruta)
## seed
set.seed(1234)
## load data
count_data_subset <- readRDS("/path/to/sex_prediction_model/data/celltype_models/training_nonneuronal_count_subset.RDS")

# Feature selection ####
VTA_Boruta <- Boruta(Identity_bin ~ ., data = count_data_subset, maxRuns = 2000, doTrace = 2)

# Save output ####
saveRDS(VTA_Boruta,"/path/to/sex_prediction_model/data/celltype_models/VTA_Boruta_max2000_nonneuronal.RDS")

# Session info ####
sessionInfo()
```

```{bash filename="boruta_selection_nonneuronal_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=boruta_selection_neuronal
#SBATCH --output=/path/to/sex_prediction_model/logs/boruta_selection_nonneuronal_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/boruta_selection_nonneuronal_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=medium
#SBATCH --time=48:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/celltype_models/boruta_selection_nonneuronal.R
```


### Cell Type Model Data Preparation
Following feature selection, model training and testing data was prepared for each neuronal and non-neuronal partition using the same workflow as with pan-cellular models.


#### Neuronal
```{r filename="prepare_model_data_neuronal.R"}
# Setup ####
## libraries
library(Seurat)
library(Boruta)
library(dplyr)

## set seed
set.seed(1234)

## load data
### Boruta object
VTA_Boruta_max2000 <- readRDS("/path/to/sex_prediction_model/data/celltype_models/VTA_Boruta_max2000_neuronal.RDS")
### training data
Rn7_VTA_training <- readRDS("/path/to/sex_prediction_model/data/celltype_models/Rn7_VTA_training_neuronal.RDS")
### training data count matrix of sex DEGs
training_count_data_sex <- readRDS("/path/to/sex_prediction_model/data/celltype_models/training_neuronal_count_subset.RDS")
### testing data
Rn7_VTA_testing <- readRDS("/path/to/sex_prediction_model/data/celltype_models/Rn7_VTA_testing_neuronal.RDS")

# Select important features ####
## Boruta information extraction
### TentativeRoughFix for tentative features
  # 54 attributes confirmed important: AC239701.1, Actb, Asb15, Atp5me, Atp5mk and 49 more;
  # 15 attributes confirmed unimportant: Abcg3l2, Calm1, Cuedc1, Eef2, ENSRNOG00000065902 and 10 more;
  # 1 tentative attributes left: Ly6h;
VTA_Boruta <- TentativeRoughFix(VTA_Boruta_max2000)
  # 55 attributes confirmed important: AC239701.1, Actb, Asb15, Atp5me, Atp5mk and 50 more;
  # 15 attributes confirmed unimportant: Abcg3l2, Calm1, Cuedc1, Eef2, ENSRNOG00000065902 and 10 more;

### extract decisions for features
VTA_Boruta_decision <- VTA_Boruta_max2000$finalDecision %>% data.frame()
colnames(VTA_Boruta_decision) <- c("finalDecision")
VTA_Boruta_decision$variable <- rownames(VTA_Boruta_decision)
VTA_Boruta_decision <- VTA_Boruta_decision %>% select(variable, finalDecision) # reorder for my sanity

### Get the column names with confirmed values
confirmed_columns <- VTA_Boruta_decision$variable[VTA_Boruta_decision$finalDecision == "Confirmed"]


# Create count data subsets ####
## For training and testing data sets, we'll use dataframes of only confirmed important predictors and the outcome identity column

## Create training count data subsets
training_count_data_sex_important <- training_count_data_sex[, colnames(training_count_data_sex) %in% confirmed_columns]
### Add identity bin back in
training_count_data_sex_important$Identity_bin <- training_count_data_sex$Identity_bin

## Create testing count data subset
count_data <- as.data.frame(t(as.matrix(GetAssayData(object = Rn7_VTA_testing,slot = "data",assay = "RNA"))))
### check if rownames are in same order as the identities vector 
all(names(Idents(Rn7_VTA_testing)) == rownames(count_data)) #TRUE 
### Now just create a new column in the count_data_full for identity
count_data$Identity <- as.factor(Rn7_VTA_testing$Sex)
### Convert identitity to binary code. 
count_data$Identity_bin <- ifelse(count_data$Identity  == "Female",
                                  1, #Females are 1
                                  0) #Males are 0
### Create a subset of count data containing the same features as the training set
test_count_data_sex_important <- count_data[,colnames(count_data) %in% colnames(training_count_data_sex_important)]

# Save outputs ####
## Boruta variable final decisions
write.csv(VTA_Boruta_decision, file = "/path/to/sex_prediction_model/data/celltype_models/Boruta_final_decisions_neuronal.csv", row.names = F)
## training and testing count data frames
write.csv(training_count_data_sex_important, file = "/path/to/sex_prediction_model/data/celltype_models/training_count_data_neuronal.csv")
write.csv(test_count_data_sex_important, file = "/path/to/sex_prediction_model/data/celltype_models/test_count_data_neuronal.csv")


# Session Info
sessionInfo()
```

```{bash filename="prepare_model_data_neuronal_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=prepare_model_data_neuronal
#SBATCH --output=/path/to/sex_prediction_model/logs/prepare_model_data_neuronal_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/prepare_model_data_neuronal_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/celltype_models/prepare_model_data_neuronal.R
```


#### Non-neuronal
```{r filename="prepare_model_data_nonneuronal.R"}
# Setup ####
## libraries
library(Seurat)
library(Boruta)
library(dplyr)

## set seed
set.seed(1234)

## load data
### Boruta object
VTA_Boruta_max2000 <- readRDS("/path/to/sex_prediction_model/data/celltype_models/VTA_Boruta_max2000_nonneuronal.RDS")
### training data
Rn7_VTA_training <- readRDS("/path/to/sex_prediction_model/data/celltype_models/Rn7_VTA_training_nonneuronal.RDS")
### training data count matrix of sex DEGs
training_count_data_sex <- readRDS("/path/to/sex_prediction_model/data/celltype_models/training_nonneuronal_count_subset.RDS")
### testing data
Rn7_VTA_testing <- readRDS("/path/to/sex_prediction_model/data/celltype_models/Rn7_VTA_testing_nonneuronal.RDS")

# Select important features ####
## Boruta information extraction
### TentativeRoughFix for tentative features
# 223 attributes confirmed important
# 126 attributes confirmed unimportant
# 11 tentative attributes left, we'll use rough fix for those
VTA_Boruta <- TentativeRoughFix(VTA_Boruta_max2000)
# 232 attributes confirmed important
# 128 attributes confirmed unimportant


### extract decisions for features
VTA_Boruta_decision <- VTA_Boruta$finalDecision %>% data.frame()
colnames(VTA_Boruta_decision) <- c("finalDecision")
VTA_Boruta_decision$variable <- rownames(VTA_Boruta_decision)
VTA_Boruta_decision <- VTA_Boruta_decision %>% select(variable, finalDecision) # reorder for my sanity

### Get the column names with confirmed values
confirmed_columns <- VTA_Boruta_decision$variable[VTA_Boruta_decision$finalDecision == "Confirmed"]


# Create count data subsets ####
## For training and testing data sets, we'll use dataframes of only confirmed important predictors and the outcome identity column

## Create training count data subsets
training_count_data_sex_important <- training_count_data_sex[, colnames(training_count_data_sex) %in% confirmed_columns]
### Add identity bin back in
training_count_data_sex_important$Identity_bin <- training_count_data_sex$Identity_bin

## Create testing count data subset
count_data <- as.data.frame(t(as.matrix(GetAssayData(object = Rn7_VTA_testing,slot = "data",assay = "RNA"))))
### check if rownames are in same order as the identities vector 
all(names(Idents(Rn7_VTA_testing)) == rownames(count_data)) #TRUE 
### Now just create a new column in the count_data_full for identity
count_data$Identity <- as.factor(Rn7_VTA_testing$Sex)
### Convert identitity to binary code. 
count_data$Identity_bin <- ifelse(count_data$Identity  == "Female",
                                  1, #Females are 1
                                  0) #Males are 0
### Create a subset of count data containing the same features as the training set
test_count_data_sex_important <- count_data[,colnames(count_data) %in% colnames(training_count_data_sex_important)]

# Save outputs ####
## Boruta variable final decisions
write.csv(VTA_Boruta_decision, file = "/path/to/sex_prediction_model/data/celltype_models/Boruta_final_decisions_nonneuronal.csv", row.names = F)
## training and testing count data frames
write.csv(training_count_data_sex_important, file = "/path/to/sex_prediction_model/data/celltype_models/training_count_data_nonneuronal.csv")
write.csv(test_count_data_sex_important, file = "/path/to/sex_prediction_model/data/celltype_models/test_count_data_nonneuronal.csv")


# Session Info
sessionInfo()
```

```{bash filename="prepare_model_data_nonneuronal_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=prepare_model_data_nonneuronal
#SBATCH --output=/path/to/sex_prediction_model/logs/prepare_model_data_nonneuronal_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/prepare_model_data_nonneuronal_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/celltype_models/prepare_model_data_nonneuronal.R
```


### Model training
Cell type-specific sex classification models were fit for neuronal and non-neuronal cell partitions using the same parameters as described in pan-cellular model training.


#### Neuronal
##### Logistic Regression
```{r filename="logistic_regression_training_neuronal.R"}
# Set up ####
## libraries
library(caret)
library(tidyverse)

## set seed
set.seed(1234)

## load data
### training dataframe
training <- read.csv("/path/to/sex_prediction_model/data/celltype_models/training_count_data_neuronal.csv", row.names = 1)
training$Identity_bin <- as.factor(training$Identity_bin)

# Train Model ####
lr_model <- glm(Identity_bin ~ .,
                data = training,
                family = "binomial")
# Summary
summary(lr_model)

# Write out files ####
saveRDS(lr_model, file = "/path/to/sex_prediction_model/data/celltype_models/models/lr_model_neuronal.RDS")

# print session Info ####
sessionInfo()
```

```{bash filename="logistic_regression_training_neuronal_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=logistic_regression_training_neuronal
#SBATCH --output=/path/to/sex_prediction_model/logs/logistic_regression_training_neuronal_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/logistic_regression_training_neuronal_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/celltype_models/logistic_regression_training_neuronal.R
```


##### Random Forest
```{r filename="randomforest_training_neuronal.R"}
# Setup ####
library(randomForest)
library(ROCR)
library(caret)
library(tidyverse)
library(doParallel)

## set seed
set.seed(1234)
## setup parallel
cl <- makePSOCKcluster(10)
registerDoParallel(cl)

## load data
### training dataframe
training <- read.csv("/path/to/sex_prediction_model/data/celltype_models/training_count_data_neuronal.csv", row.names = 1)
training$Identity_bin <- recode(training$Identity_bin, `0` = "Male", `1` = "Female")
training$Identity_bin <- factor(training$Identity_bin, levels = c("Male", "Female"))

# Train Model ####
mtry_values <- seq(from = 2, to = 334, by = 12)

# Generate all combinations
tune.grid <- expand.grid(mtry = mtry_values)

train.ctrl <- trainControl(method = "repeatedcv",
                           number = 10,
                           repeats = 3,
                           classProbs = T,
                           allowParallel = T)
rf_model <- train(Identity_bin ~ ., data = training, 
                  method = "rf",
                  trControl = train.ctrl,
                  tuneGrid = tune.grid,
                  ntree = 1000)
rf_model

stopCluster(cl)

# Write out files ####
saveRDS(rf_model, file = "/path/to/sex_prediction_model/data/celltype_models/models/rf_model_neuronal.RDS")

# print session Info ####
sessionInfo()
```

```{bash filename="randomforest_training_neuronal_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=randomforest_training_neuronal
#SBATCH --output=/path/to/sex_prediction_model/logs/randomforest_training_neuronal_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/randomforest_training_neuronal_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=long
#SBATCH --time=150:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/celltype_models/randomforest_training_neuronal.R
```


##### Support Vector Machine
```{r filename="svm_training_neuronal.R"}
# Setup ####
library(kernlab)
library(ROCR)
library(caret)
library(tidyverse)
library(doParallel)

## set seed
set.seed(1234)
## setup parallel
cl <- makePSOCKcluster(10)
registerDoParallel(cl)

## load data
### training data frame
training <- read.csv("/path/to/sex_prediction_model/data/celltype_models/training_count_data_neuronal.csv", row.names = 1)
training$Identity_bin <- recode(training$Identity_bin, `0` = "Male", `1` = "Female")
training$Identity_bin <- factor(training$Identity_bin, levels = c("Male", "Female"))

# Train Model ####
## Create vectors for sigma and C
sigma_values <- c(0.0001,0.001,0.01,0.1,1)
C_values <- c(0.01,0.1,0.2,0.5,1,1.5,2,5,10)

## Generate training grid
train.grid <- expand.grid(sigma = sigma_values, C = C_values)

## create training control parameters
train.ctrl <- trainControl(method = "repeatedcv",
                           number = 10,
                           repeats = 3,
                           classProbs = T,
                           allowParallel = T)

svm_model <- train(Identity_bin ~ ., data = training, 
                   method = "svmRadial",
                   verbose = T,
                   trControl = train.ctrl,
                   tuneGrid = train.grid)

svm_model

stopCluster(cl)
# Write out files ####
saveRDS(svm_model, file = "/path/to/sex_prediction_model/data/celltype_models/models/svm_rad_model_neuronal.RDS")

# print session Info ####
sessionInfo()
```

```{bash filename="svm_training_neuronal_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=svm_training_neuronal
#SBATCH --output=/path/to/sex_prediction_model/logs/svm_training_neuronal_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/svm_training_neuronal_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=long
#SBATCH --time=150:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/celltype_models/svm_training_neuronal.R
```


##### Multilayer Perceptron with weights
```{r filename="mlp_training_neuronal.R"}
# Set up ####
## libraries
library(RSNNS)
library(ROCR)
library(caret)
library(tidyverse)
library(doParallel)

## set seed
set.seed(1234)
## setup parallel
cl <- makePSOCKcluster(10)
registerDoParallel(cl)

## load data
### training dataframe
training <- read.csv("/path/to/sex_prediction_model/data/celltype_models/training_count_data_neuronal.csv", row.names = 1)
training$Identity_bin <- recode(training$Identity_bin, `0` = "Male", `1` = "Female")
training$Identity_bin <- factor(training$Identity_bin, levels = c("Male", "Female"))

# Train Model ####
# Create vectors for layer1, layer2, and decay
layer1_values <- c(1,seq(from = 5, to = 20, by = 5))
layer2_values <- c(0, round(layer1_values / 2)) %>% unique()
layer3_values <- round(layer2_values / 2)  
decay_values <- seq(from = 0, to = 0.2, by = 0.05)

# Generate all combinations
train.grid <- expand.grid(layer1 = layer1_values,
                          layer2 = layer2_values,
                          layer3 = layer3_values,
                          decay = decay_values)

# Filter rows where layer2 is smaller than layer1
train.grid <- train.grid[train.grid$layer2 < train.grid$layer1, ]

# Filter rows where layer3 is smaller than layer2
train.grid <- train.grid[train.grid$layer3 < train.grid$layer2, ]

train.ctrl <- trainControl(method = "repeatedcv",
                           number = 10,
                           repeats = 3,
                           classProbs = T,
                           allowParallel = T)
mlp_model <- caret::train(Identity_bin ~ ., data = training, 
                          method = "mlpWeightDecayML",
                          trControl = train.ctrl,
                          tuneGrid = train.grid)

mlp_model

stopCluster(cl)
# Write out files ####
saveRDS(mlp_model, file = "/path/to/sex_prediction_model/data/celltype_models/models/mlpwdml_model_neuronal.RDS")

# print session Info ####
sessionInfo()
```

```{bash filename="mlp_training_neuronal_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=mlp_training_neuronal
#SBATCH --output=/path/to/sex_prediction_model/logs/mlp_training_neuronal_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/mlp_training_neuronal_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=long
#SBATCH --time=150:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/celltype_models/mlp_training_neuronal.R
```


##### Simple Y expression classifier
```{r filename="chrY_classifier_neuronal.R"}
# Setup ####
## libraries
library(ggplot2)
library(dplyr)
library(tibble)
library(Seurat)
library(pROC)
library(caret)

## data
### training object data
training.object <- readRDS("/path/to/sex_prediction_model/data/celltype_models/Rn7_VTA_training_neuronal.RDS")
### testing object data
testing.object <- readRDS("/path/to/sex_prediction_model/data/celltype_models/Rn7_VTA_testing_neuronal.RDS")

### gene chromosome data
Rn7.gtf <- rtracklayer::import("/path/to/sex_prediction_model/data/Rattus_norvegicus.mRatBN7.2.105.gtf")
Rn7.gtf <- as.data.frame(Rn7.gtf)

## functions
y.count <- function(srat.object){
  # load gene expression count data
  srat.counts <- as.data.frame(t(as.matrix(GetAssayData(object = srat.object, slot = "data", assay = "RNA"))))
  
  # load gene annotations
  Rn7.gtf <- rtracklayer::import("/path/to/sex_prediction_model/data/Rattus_norvegicus.mRatBN7.2.105.gtf")
  Rn7.gtf <- as.data.frame(Rn7.gtf)
  
  # select Y chromosome genes
  y.genes <- Rn7.gtf %>% #from Rn7 gene annotations
    filter(seqnames == "Y") %>% #filter for chrY only
    select(gene_id, gene_name) %>% #select gene ids and names
    mutate(gene_name = coalesce(gene_name, gene_id)) %>% #replace NA name values with gene ID
    pull(gene_name) %>% #pull gene name values
    unique() #only unique values, returns 27 genes
  
  # create cumulative expresion of Y genes
  y.counts <- srat.counts %>%
    select(any_of(y.genes)) %>%
    rowSums() %>% data.frame()
  ### set column name
  colnames(y.counts) <- c("y.counts")
  
  return(y.counts)
}
y.class.threshold <- function(srat.object){
  class.roc <- roc(srat.object$Sex,srat.object$y.counts)
  threshold <- coords(class.roc, x = "best")
  return(threshold$threshold)
}
y.count.classify <- function(srat.object, threshold){
  classifications <- case_when(srat.object$y.counts > threshold ~ "Male",
                               TRUE ~ "Female")
  return(classifications)
}


# Prepare classifiers ####
## Sum chrY counts
training.object$y.counts <- y.count(training.object)

## chrY summary stats
### distributions
#### overall
overall.distb <- ggplot(data = training.object@meta.data, mapping = aes(x = y.counts)) +
  geom_histogram(bins = 20, color = "black", fill = "lightgrey") +
  labs(title = "Chromosome Y gene count distribution", x = "Gene count", y = "Cell count") +
  theme_bw()

#### split by sex
wrap.distb <- ggplot(data = training.object@meta.data, mapping = aes(x = y.counts)) +
  geom_histogram(bins = 20, color = "black", fill = "lightgrey") +
  labs(title = "Chromosome Y gene count distribution", x = "Gene count", y = "Cell count") +
  facet_wrap(~ Sex) +
  theme_bw()

#### save plots
ggsave(plot = overall.distb,
       filename = "/path/to/sex_prediction_model/output/celltype_models/Ydistb.training.neuronal.all.pdf",
       height = 5,
       width = 5)

ggsave(plot = wrap.distb,
       filename = "/path/to/sex_prediction_model/output/celltype_models/Ydistb.training.neuronal.split.pdf",
       height = 5,
       width = 10)


### summary statistics
#### overall
overall.stats <- data.frame(min = min(training.object$y.counts), 
                            Q1 = quantile(training.object$y.counts, 0.25),
                            median = median(training.object$y.counts),
                            mean = mean(training.object$y.counts),
                            Q3 = quantile(training.object$y.counts, 0.75),
                            max = max(training.object$y.counts))
rownames(overall.stats) <- c("Overall")

#### split by sex
summary.stats <- training.object@meta.data %>% 
  group_by(Sex) %>% 
  summarize(
    min = min(y.counts),
    Q1 = quantile(y.counts, 0.25),
    median = median(y.counts),
    mean = mean(y.counts),
    Q3 = quantile(y.counts, 0.75),
    max = max(y.counts)
  ) %>% 
  data.frame() %>% 
  column_to_rownames(var = "Sex")

#### bind 
stats.df <- bind_rows(summary.stats, overall.stats)
#### write out
write.csv(stats.df, file = "/path/to/sex_prediction_model/output/celltype_models/Ydistb.training.neuronal.sumstats.csv")

## Set classification threshold
### ROC curve
simple.roc <- roc(training.object$Sex,training.object$y.counts)

### save plot 
roc.plot <- ggroc(data = simple.roc) +
  geom_abline(slope = 1, intercept = 1, linetype = "dashed") +
  theme_bw()
ggsave(filename = "/path/to/sex_prediction_model/output/celltype_models/Ydistb.training.neuronal.roc.pdf",
       plot = roc.plot,
       height = 5,
       width = 5)

### set threshold
threshold <- y.class.threshold(training.object)


# Make classification predictions ####
## sum chrY counts
testing.object$y.counts <- y.count(testing.object)
## make precition
testing.object$Sex.prediction <- y.count.classify(testing.object, 0)
testing.object$Sex.roc.prediction <- y.count.classify(testing.object, threshold)
## save predictions
testing.predictions <- testing.object@meta.data %>% select(Sex, y.counts, Sex.prediction, Sex.roc.prediction)
write.csv(testing.predictions, file = "/path/to/sex_prediction_model/output/celltype_models/Yclass.predictions.neuronal.csv")


# Evaluate performance ####
## make Sex and predicted Sex a factor
testing.object@meta.data <- testing.object@meta.data %>% mutate(Sex = factor(testing.object$Sex, levels = c("Male", "Female")),
                                                                Sex.prediction = factor(testing.object$Sex.prediction, levels = c("Male", "Female")),
                                                                Sex.roc.prediction = factor(testing.object$Sex.roc.prediction, levels = c("Male", "Female")))

print("Threshold 0 predictions")
confusionMatrix(testing.object$Sex.prediction, testing.object$Sex)

print(paste0("Threshold ", threshold, " predictions"))
confusionMatrix(testing.object$Sex.roc.prediction, testing.object$Sex)


# sessionInfo ####
sessionInfo()
```

```{bash filename="chrY_classifier_neuronal_run.R"}
#!/bin/bash
#
#SBATCH --job-name=chrY_classifier_neuronal
#SBATCH --output=/path/to/sex_prediction_model/logs/chrY_classifier_neuronal_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/chrY_classifier_neuronal_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/celltype_models/chrY_classifier_neuronal.R
```


##### Simple Xist expression classifier
```{r filename="Xist_classifier_neuronal.R"}
# Setup ####
## libraries
library(ggplot2)
library(dplyr)
library(tibble)
library(Seurat)
library(pROC)
library(caret)

## data
### training object data
training.object <- readRDS("/path/to/sex_prediction_model/data/celltype_models/Rn7_VTA_training_neuronal.RDS")
### testing object data
testing.object <- readRDS("/path/to/sex_prediction_model/data/celltype_models/Rn7_VTA_testing_neuronal.RDS")

## functions
Xist.count <- function(srat.object){
  # load gene expression count data
  Xist.counts <- as.data.frame(t(as.matrix(GetAssayData(object = srat.object, slot = "data", assay = "RNA")))) %>%
    pull("ENSRNOG00000065796") # pull out Xist (named as ENSRNOG00000065796)
  
  return(Xist.counts)
}
Xist.class.threshold <- function(srat.object){
  class.roc <- roc(srat.object$Sex,srat.object$Xist.counts, levels = c("Male", "Female"))
  threshold <- coords(class.roc, x = "best")
  return(threshold$threshold)
}
Xist.count.classify <- function(srat.object, threshold){
  classifications <- case_when(srat.object$Xist.counts > threshold ~ "Female",
                               TRUE ~ "Male")
  return(classifications)
}


# Prepare classifier ####
## Sum Xist counts
training.object$Xist.counts <- Xist.count(training.object)

## Xist summary stats
### distributions
#### overall
overall.distb <- ggplot(data = training.object@meta.data, mapping = aes(x = Xist.counts)) +
  geom_histogram(bins = 20, color = "black", fill = "lightgrey") +
  labs(title = "Xist gene count distribution", x = "Gene count", y = "Cell count") +
  theme_bw()

#### split by sex
wrap.distb <- ggplot(data = training.object@meta.data, mapping = aes(x = Xist.counts)) +
  geom_histogram(bins = 20, color = "black", fill = "lightgrey") +
  labs(title = "Xist gene count distribution", x = "Gene count", y = "Cell count") +
  facet_wrap(~ Sex) +
  theme_bw()

#### save plots
ggsave(plot = overall.distb,
       filename = "/path/to/sex_prediction_model/output/celltype_models/Xist.distb.training.neuronal.all.pdf",
       height = 5,
       width = 5)

ggsave(plot = wrap.distb,
       filename = "/path/to/sex_prediction_model/output/celltype_models/Xist.distb.training.neuronal.split.pdf",
       height = 5,
       width = 10)


### summary statistics
#### overall
overall.stats <- data.frame(min = min(training.object$Xist.counts), 
                            Q1 = quantile(training.object$Xist.counts, 0.25),
                            median = median(training.object$Xist.counts),
                            mean = mean(training.object$Xist.counts),
                            Q3 = quantile(training.object$Xist.counts, 0.75),
                            max = max(training.object$Xist.counts))
rownames(overall.stats) <- c("Overall")

#### split by sex
summary.stats <- training.object@meta.data %>% 
  group_by(Sex) %>% 
  summarize(
    min = min(Xist.counts),
    Q1 = quantile(Xist.counts, 0.25),
    median = median(Xist.counts),
    mean = mean(Xist.counts),
    Q3 = quantile(Xist.counts, 0.75),
    max = max(Xist.counts)
  ) %>% 
  data.frame() %>% 
  column_to_rownames(var = "Sex")

#### bind 
stats.df <- bind_rows(summary.stats, overall.stats)
#### write out
write.csv(stats.df, file = "/path/to/sex_prediction_model/output/celltype_models/Xist.distb.training.neuronal.sumstats.csv")

## Set classification threshold
### ROC curve
simple.roc <- roc(training.object$Sex,training.object$Xist.counts,
                  levels = c("Female", "Male"),
                  direction = ">"
)

### save plot 
roc.plot <- 
  ggroc(data = simple.roc, legacy.axes = F) +
  geom_abline(slope = 1, intercept = 1, linetype = "dashed") +
  theme_bw()
ggsave(filename = "/path/to/sex_prediction_model/output/celltype_models/Xist.training.neuronal.roc.pdf",
       plot = roc.plot,
       height = 5,
       width = 5)

### set threshold
threshold <- Xist.class.threshold(training.object)


# Make classification predictions ####
## sum chrY counts
testing.object$Xist.counts <- Xist.count(testing.object)
## make precition
testing.object$Sex.prediction <- Xist.count.classify(testing.object, 0)
testing.object$Sex.roc.prediction <- Xist.count.classify(testing.object, threshold)
## save predictions
testing.predictions <- testing.object@meta.data %>% select(Sex, Xist.counts, Sex.prediction, Sex.roc.prediction)
write.csv(testing.predictions, file = "/path/to/sex_prediction_model/output/celltype_models/Xist.class.predictions.neuronal.csv")


# Evaluate performance ####
## make Sex and predicted Sex a factor
testing.object@meta.data <- testing.object@meta.data %>% mutate(Sex = factor(testing.object$Sex, levels = c("Male", "Female")),
                                                                Sex.prediction = factor(testing.object$Sex.prediction, levels = c("Male", "Female")),
                                                                Sex.roc.prediction = factor(testing.object$Sex.roc.prediction, levels = c("Male", "Female")))

print("Threshold 0 predictions")
confusionMatrix(testing.object$Sex.prediction, testing.object$Sex)

print(paste0("Threshold ", threshold, " predictions"))
confusionMatrix(testing.object$Sex.roc.prediction, testing.object$Sex)


# sessionInfo ####
sessionInfo()
```

```{bash filename="Xist_classifier_neuronal_run.R"}
#!/bin/bash
#
#SBATCH --job-name=Xist_classifier_neuronal
#SBATCH --output=/path/to/sex_prediction_model/logs/Xist_classifier_neuronal_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/Xist_classifier_neuronal_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/celltype_models/Xist_classifier_neuronal.R
```


#### Non-neuronal
##### Logistic Regression
```{r filename="logistic_regression_training_nonneuronal.R"}
# Set up ####
## libraries
library(caret)
library(tidyverse)

## set seed
set.seed(1234)

## load data
### training dataframe
training <- read.csv("/path/to/sex_prediction_model/data/celltype_models/training_count_data_nonneuronal.csv", row.names = 1)
training$Identity_bin <- as.factor(training$Identity_bin)

# Train Model ####
lr_model <- glm(Identity_bin ~ .,
                data = training,
                family = "binomial")
# Summary
summary(lr_model)

# Write out files ####
saveRDS(lr_model, file = "/path/to/sex_prediction_model/data/celltype_models/models/lr_model_nonneuronal.RDS")

# print session Info ####
sessionInfo()
```

```{bash filename="logistic_regression_training_nonneuronal_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=logistic_regression_training_nonneuronal
#SBATCH --output=/path/to/sex_prediction_model/logs/logistic_regression_training_nonneuronal_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/logistic_regression_training_nonneuronal_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/celltype_models/logistic_regression_training_nonneuronal.R
```


##### Random Forest
```{r filename="randomforest_training_nonneuronal.R"}
# Setup ####
library(randomForest)
library(ROCR)
library(caret)
library(tidyverse)
library(doParallel)

## set seed
set.seed(1234)
## setup parallel
cl <- makePSOCKcluster(10)
registerDoParallel(cl)

## load data
### training dataframe
training <- read.csv("/path/to/sex_prediction_model/data/celltype_models/training_count_data_nonneuronal.csv", row.names = 1)
training$Identity_bin <- recode(training$Identity_bin, `0` = "Male", `1` = "Female")
training$Identity_bin <- factor(training$Identity_bin, levels = c("Male", "Female"))

# Train Model ####
mtry_values <- seq(from = 2, to = 334, by = 12)

# Generate all combinations
tune.grid <- expand.grid(mtry = mtry_values)

train.ctrl <- trainControl(method = "repeatedcv",
                           number = 10,
                           repeats = 3,
                           classProbs = T,
                           allowParallel = T)
rf_model <- train(Identity_bin ~ ., data = training, 
                  method = "rf",
                  trControl = train.ctrl,
                  tuneGrid = tune.grid,
                  ntree = 1000)
rf_model

stopCluster(cl)

# Write out files ####
saveRDS(rf_model, file = "/path/to/sex_prediction_model/data/celltype_models/models/rf_model_nonneuronal.RDS")

# print session Info ####
sessionInfo()
```

```{bash filename="randomforest_training_nonneuronal_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=randomforest_training_nonneuronal
#SBATCH --output=/path/to/sex_prediction_model/logs/randomforest_training_nonneuronal_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/randomforest_training_nonneuronal_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=long
#SBATCH --time=150:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/celltype_models/randomforest_training_nonneuronal.R
```


##### Support Vector Machine
```{r filename="svm_training_nonneuronal.R"}
# Setup ####
library(kernlab)
library(ROCR)
library(caret)
library(tidyverse)
library(doParallel)

## set seed
set.seed(1234)
## setup parallel
cl <- makePSOCKcluster(10)
registerDoParallel(cl)

## load data
### training data frame
training <- read.csv("/path/to/sex_prediction_model/data/celltype_models/training_count_data_nonneuronal.csv", row.names = 1)
training$Identity_bin <- recode(training$Identity_bin, `0` = "Male", `1` = "Female")
training$Identity_bin <- factor(training$Identity_bin, levels = c("Male", "Female"))

# Train Model ####
## Create vectors for sigma and C
sigma_values <- c(0.0001,0.001,0.01,0.1,1)
C_values <- c(0.01,0.1,0.2,0.5,1,1.5,2,5,10)

## Generate training grid
train.grid <- expand.grid(sigma = sigma_values, C = C_values)

## create training control parameters
train.ctrl <- trainControl(method = "repeatedcv",
                           number = 10,
                           repeats = 3,
                           classProbs = T,
                           allowParallel = T)

svm_model <- train(Identity_bin ~ ., data = training, 
                   method = "svmRadial",
                   verbose = T,
                   trControl = train.ctrl,
                   tuneGrid = train.grid)

svm_model

stopCluster(cl)
# Write out files ####
saveRDS(svm_model, file = "/path/to/sex_prediction_model/data/celltype_models/models/svm_rad_model_nonneuronal.RDS")

# print session Info ####
sessionInfo()
```

```{bash filename="svm_training_nonneuronal_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=svm_training_nonneuronal
#SBATCH --output=/path/to/sex_prediction_model/logs/svm_training_nonneuronal_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/svm_training_nonneuronal_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=long
#SBATCH --time=150:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/celltype_models/svm_training_nonneuronal.R
```


##### Multilayer Perceptron with weights
```{r filename="mlp_training_nonneuronal.R"}
# Set up ####
## libraries
library(RSNNS)
library(ROCR)
library(caret)
library(tidyverse)
library(doParallel)

## set seed
set.seed(1234)
## setup parallel
cl <- makePSOCKcluster(10)
registerDoParallel(cl)

## load data
### training dataframe
training <- read.csv("/path/to/sex_prediction_model/data/celltype_models/training_count_data_nonneuronal.csv", row.names = 1)
training$Identity_bin <- recode(training$Identity_bin, `0` = "Male", `1` = "Female")
training$Identity_bin <- factor(training$Identity_bin, levels = c("Male", "Female"))

# Train Model ####
# Create vectors for layer1, layer2, and decay
layer1_values <- c(1,seq(from = 5, to = 20, by = 5))
layer2_values <- c(0, round(layer1_values / 2)) %>% unique()
layer3_values <- round(layer2_values / 2)  
decay_values <- seq(from = 0, to = 0.2, by = 0.05)

# Generate all combinations
train.grid <- expand.grid(layer1 = layer1_values,
                          layer2 = layer2_values,
                          layer3 = layer3_values,
                          decay = decay_values)

# Filter rows where layer2 is smaller than layer1
train.grid <- train.grid[train.grid$layer2 < train.grid$layer1, ]

# Filter rows where layer3 is smaller than layer2
train.grid <- train.grid[train.grid$layer3 < train.grid$layer2, ]

train.ctrl <- trainControl(method = "repeatedcv",
                           number = 10,
                           repeats = 3,
                           classProbs = T,
                           allowParallel = T)
mlp_model <- caret::train(Identity_bin ~ ., data = training, 
                          method = "mlpWeightDecayML",
                          trControl = train.ctrl,
                          tuneGrid = train.grid)

mlp_model

stopCluster(cl)
# Write out files ####
saveRDS(mlp_model, file = "/path/to/sex_prediction_model/data/celltype_models/models/mlpwdml_model_nonneuronal.RDS")

# print session Info ####
sessionInfo()
```

```{bash filename="mlp_training_nonneuronal_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=mlp_training_nonneuronal
#SBATCH --output=/path/to/sex_prediction_model/logs/mlp_training_nonneuronal_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/mlp_training_nonneuronal_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=long
#SBATCH --time=150:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/celltype_models/mlp_training_nonneuronal.R
```


##### Simple Y expression classifier
```{r filename="chrY_classifier_nonneuronal.R"}
# Setup ####
## libraries
library(ggplot2)
library(dplyr)
library(tibble)
library(Seurat)
library(pROC)
library(caret)

## data
### training object data
training.object <- readRDS("/path/to/sex_prediction_model/data/celltype_models/Rn7_VTA_training_nonneuronal.RDS")
### testing object data
testing.object <- readRDS("/path/to/sex_prediction_model/data/celltype_models/Rn7_VTA_testing_nonneuronal.RDS")

### gene chromosome data
Rn7.gtf <- rtracklayer::import("/path/to/sex_prediction_model/data/Rattus_norvegicus.mRatBN7.2.105.gtf")
Rn7.gtf <- as.data.frame(Rn7.gtf)

## functions
y.count <- function(srat.object){
  # load gene expression count data
  srat.counts <- as.data.frame(t(as.matrix(GetAssayData(object = srat.object, slot = "data", assay = "RNA"))))
  
  # load gene annotations
  Rn7.gtf <- rtracklayer::import("/path/to/sex_prediction_model/data/Rattus_norvegicus.mRatBN7.2.105.gtf")
  Rn7.gtf <- as.data.frame(Rn7.gtf)
  
  # select Y chromosome genes
  y.genes <- Rn7.gtf %>% #from Rn7 gene annotations
    filter(seqnames == "Y") %>% #filter for chrY only
    select(gene_id, gene_name) %>% #select gene ids and names
    mutate(gene_name = coalesce(gene_name, gene_id)) %>% #replace NA name values with gene ID
    pull(gene_name) %>% #pull gene name values
    unique() #only unique values, returns 27 genes
  
  # create cumulative expresion of Y genes
  y.counts <- srat.counts %>%
    select(any_of(y.genes)) %>%
    rowSums() %>% data.frame()
  ### set column name
  colnames(y.counts) <- c("y.counts")
  
  return(y.counts)
}
y.class.threshold <- function(srat.object){
  class.roc <- roc(srat.object$Sex,srat.object$y.counts)
  threshold <- coords(class.roc, x = "best")
  return(threshold$threshold)
}
y.count.classify <- function(srat.object, threshold){
  classifications <- case_when(srat.object$y.counts > threshold ~ "Male",
                               TRUE ~ "Female")
  return(classifications)
}


# Prepare classifiers ####
## Sum chrY counts
training.object$y.counts <- y.count(training.object)

## chrY summary stats
### distributions
#### overall
overall.distb <- ggplot(data = training.object@meta.data, mapping = aes(x = y.counts)) +
  geom_histogram(bins = 20, color = "black", fill = "lightgrey") +
  labs(title = "Chromosome Y gene count distribution", x = "Gene count", y = "Cell count") +
  theme_bw()

#### split by sex
wrap.distb <- ggplot(data = training.object@meta.data, mapping = aes(x = y.counts)) +
  geom_histogram(bins = 20, color = "black", fill = "lightgrey") +
  labs(title = "Chromosome Y gene count distribution", x = "Gene count", y = "Cell count") +
  facet_wrap(~ Sex) +
  theme_bw()

#### save plots
ggsave(plot = overall.distb,
       filename = "/path/to/sex_prediction_model/output/celltype_models/Ydistb.training.nonneuronal.all.pdf",
       height = 5,
       width = 5)

ggsave(plot = wrap.distb,
       filename = "/path/to/sex_prediction_model/output/celltype_models/Ydistb.training.nonneuronal.split.pdf",
       height = 5,
       width = 10)


### summary statistics
#### overall
overall.stats <- data.frame(min = min(training.object$y.counts), 
                            Q1 = quantile(training.object$y.counts, 0.25),
                            median = median(training.object$y.counts),
                            mean = mean(training.object$y.counts),
                            Q3 = quantile(training.object$y.counts, 0.75),
                            max = max(training.object$y.counts))
rownames(overall.stats) <- c("Overall")

#### split by sex
summary.stats <- training.object@meta.data %>% 
  group_by(Sex) %>% 
  summarize(
    min = min(y.counts),
    Q1 = quantile(y.counts, 0.25),
    median = median(y.counts),
    mean = mean(y.counts),
    Q3 = quantile(y.counts, 0.75),
    max = max(y.counts)
  ) %>% 
  data.frame() %>% 
  column_to_rownames(var = "Sex")

#### bind 
stats.df <- bind_rows(summary.stats, overall.stats)
#### write out
write.csv(stats.df, file = "/path/to/sex_prediction_model/output/celltype_models/Ydistb.training.nonneuronal.sumstats.csv")

## Set classification threshold
### ROC curve
simple.roc <- roc(training.object$Sex,training.object$y.counts)

### save plot 
roc.plot <- ggroc(data = simple.roc) +
  geom_abline(slope = 1, intercept = 1, linetype = "dashed") +
  theme_bw()
ggsave(filename = "/path/to/sex_prediction_model/output/celltype_models/Ydistb.training.nonneuronal.roc.pdf",
       plot = roc.plot,
       height = 5,
       width = 5)

### set threshold
threshold <- y.class.threshold(training.object)


# Make classification predictions ####
## sum chrY counts
testing.object$y.counts <- y.count(testing.object)
## make precition
testing.object$Sex.prediction <- y.count.classify(testing.object, 0)
testing.object$Sex.roc.prediction <- y.count.classify(testing.object, threshold)
## save predictions
testing.predictions <- testing.object@meta.data %>% select(Sex, y.counts, Sex.prediction, Sex.roc.prediction)
write.csv(testing.predictions, file = "/path/to/sex_prediction_model/output/celltype_models/Yclass.predictions.nonneuronal.csv")


# Evaluate performance ####
## make Sex and predicted Sex a factor
testing.object@meta.data <- testing.object@meta.data %>% mutate(Sex = factor(testing.object$Sex, levels = c("Male", "Female")),
                                                                Sex.prediction = factor(testing.object$Sex.prediction, levels = c("Male", "Female")),
                                                                Sex.roc.prediction = factor(testing.object$Sex.roc.prediction, levels = c("Male", "Female")))

print("Threshold 0 predictions")
confusionMatrix(testing.object$Sex.prediction, testing.object$Sex)

print(paste0("Threshold ", threshold, " predictions"))
confusionMatrix(testing.object$Sex.roc.prediction, testing.object$Sex)


# sessionInfo ####
sessionInfo()
```

```{bash filename="chrY_classifier_nonneuronal_run.R"}
#!/bin/bash
#
#SBATCH --job-name=chrY_classifier_nonneuronal
#SBATCH --output=/path/to/sex_prediction_model/logs/chrY_classifier_nonneuronal_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/chrY_classifier_nonneuronal_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/celltype_models/chrY_classifier_nonneuronal.R
```


##### Simple Xist expression classifier
```{r filename="Xist_classifier_nonneuronal.R"}
# Setup ####
## libraries
library(ggplot2)
library(dplyr)
library(tibble)
library(Seurat)
library(pROC)
library(caret)

## data
### training object data
training.object <- readRDS("/path/to/sex_prediction_model/data/celltype_models/Rn7_VTA_training_nonneuronal.RDS")
### testing object data
testing.object <- readRDS("/path/to/sex_prediction_model/data/celltype_models/Rn7_VTA_testing_nonneuronal.RDS")

## functions
Xist.count <- function(srat.object){
  # load gene expression count data
  Xist.counts <- as.data.frame(t(as.matrix(GetAssayData(object = srat.object, slot = "data", assay = "RNA")))) %>%
    pull("ENSRNOG00000065796") # pull out Xist (named as ENSRNOG00000065796)
  
  return(Xist.counts)
}
Xist.class.threshold <- function(srat.object){
  class.roc <- roc(srat.object$Sex,srat.object$Xist.counts, levels = c("Male", "Female"))
  threshold <- coords(class.roc, x = "best")
  return(threshold$threshold)
}
Xist.count.classify <- function(srat.object, threshold){
  classifications <- case_when(srat.object$Xist.counts > threshold ~ "Female",
                               TRUE ~ "Male")
  return(classifications)
}


# Prepare classifier ####
## Sum Xist counts
training.object$Xist.counts <- Xist.count(training.object)

## Xist summary stats
### distributions
#### overall
overall.distb <- ggplot(data = training.object@meta.data, mapping = aes(x = Xist.counts)) +
  geom_histogram(bins = 20, color = "black", fill = "lightgrey") +
  labs(title = "Xist gene count distribution", x = "Gene count", y = "Cell count") +
  theme_bw()

#### split by sex
wrap.distb <- ggplot(data = training.object@meta.data, mapping = aes(x = Xist.counts)) +
  geom_histogram(bins = 20, color = "black", fill = "lightgrey") +
  labs(title = "Xist gene count distribution", x = "Gene count", y = "Cell count") +
  facet_wrap(~ Sex) +
  theme_bw()

#### save plots
ggsave(plot = overall.distb,
       filename = "/path/to/sex_prediction_model/output/celltype_models/Xist.distb.training.nonneuronal.all.pdf",
       height = 5,
       width = 5)

ggsave(plot = wrap.distb,
       filename = "/path/to/sex_prediction_model/output/celltype_models/Xist.distb.training.nonneuronal.split.pdf",
       height = 5,
       width = 10)


### summary statistics
#### overall
overall.stats <- data.frame(min = min(training.object$Xist.counts), 
                            Q1 = quantile(training.object$Xist.counts, 0.25),
                            median = median(training.object$Xist.counts),
                            mean = mean(training.object$Xist.counts),
                            Q3 = quantile(training.object$Xist.counts, 0.75),
                            max = max(training.object$Xist.counts))
rownames(overall.stats) <- c("Overall")

#### split by sex
summary.stats <- training.object@meta.data %>% 
  group_by(Sex) %>% 
  summarize(
    min = min(Xist.counts),
    Q1 = quantile(Xist.counts, 0.25),
    median = median(Xist.counts),
    mean = mean(Xist.counts),
    Q3 = quantile(Xist.counts, 0.75),
    max = max(Xist.counts)
  ) %>% 
  data.frame() %>% 
  column_to_rownames(var = "Sex")

#### bind 
stats.df <- bind_rows(summary.stats, overall.stats)
#### write out
write.csv(stats.df, file = "/path/to/sex_prediction_model/output/celltype_models/Xist.distb.training.nonneuronal.sumstats.csv")

## Set classification threshold
### ROC curve
simple.roc <- roc(training.object$Sex,training.object$Xist.counts,
                  levels = c("Female", "Male"),
                  direction = ">"
)

### save plot 
roc.plot <- 
  ggroc(data = simple.roc, legacy.axes = F) +
  geom_abline(slope = 1, intercept = 1, linetype = "dashed") +
  theme_bw()
ggsave(filename = "/path/to/sex_prediction_model/output/celltype_models/Xist.training.nonneuronal.roc.pdf",
       plot = roc.plot,
       height = 5,
       width = 5)

### set threshold
threshold <- Xist.class.threshold(training.object)


# Make classification predictions ####
## sum chrY counts
testing.object$Xist.counts <- Xist.count(testing.object)
## make precition
testing.object$Sex.prediction <- Xist.count.classify(testing.object, 0)
testing.object$Sex.roc.prediction <- Xist.count.classify(testing.object, threshold)
## save predictions
testing.predictions <- testing.object@meta.data %>% select(Sex, Xist.counts, Sex.prediction, Sex.roc.prediction)
write.csv(testing.predictions, file = "/path/to/sex_prediction_model/output/celltype_models/Xist.class.predictions.nonneuronal.csv")


# Evaluate performance ####
## make Sex and predicted Sex a factor
testing.object@meta.data <- testing.object@meta.data %>% mutate(Sex = factor(testing.object$Sex, levels = c("Male", "Female")),
                                                                Sex.prediction = factor(testing.object$Sex.prediction, levels = c("Male", "Female")),
                                                                Sex.roc.prediction = factor(testing.object$Sex.roc.prediction, levels = c("Male", "Female")))

print("Threshold 0 predictions")
confusionMatrix(testing.object$Sex.prediction, testing.object$Sex)

print(paste0("Threshold ", threshold, " predictions"))
confusionMatrix(testing.object$Sex.roc.prediction, testing.object$Sex)


# sessionInfo ####
sessionInfo()
```

```{bash filename="Xist_classifier_nonneuronal_run.R"}
#!/bin/bash
#
#SBATCH --job-name=Xist_classifier_nonneuronal
#SBATCH --output=/path/to/sex_prediction_model/logs/Xist_classifier_nonneuronal_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/Xist_classifier_nonneuronal_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/celltype_models/Xist_classifier_nonneuronal.R
```


### Model evaluation
As with pan-cellular models, overall accuracy and sensitivity and specificity were assessed for each model. Each cell type-specific model was evaluated using its respective cell type testing partition.

#### Neuronal
```{r filename="overall_performance_neuronal.R"}
# Setup ####
## libraries
library(randomForest)
library(kernlab)
library(RSNNS)
library(caret)
library(ROCR)
library(pROC)
library(ggplot2)
library(dplyr)
library(tidyr)

## set seed
set.seed(1234)

## data
### models
svm_model <- readRDS("/path/to/sex_prediction_model/data/celltype_models/models/svm_rad_model_neuronal.RDS")
rf_model <- readRDS("/path/to/sex_prediction_model/data/celltype_models/models/rf_model_neuronal.RDS")
mlp_model <- readRDS("/path/to/sex_prediction_model/data/celltype_models/models/mlpwdml_model_neuronal.RDS")
lr_model <- readRDS("/path/to/sex_prediction_model/data/celltype_models/models/lr_model_neuronal.RDS")
chrY_model <- read.csv("/path/to/sex_prediction_model/output/celltype_models/Yclass.predictions.neuronal.csv", row.names = 1)
Xist_model <- read.csv("/path/to/sex_prediction_model/output/celltype_models/Xist.class.predictions.neuronal.csv", row.names = 1)

### testing data
testing <- read.csv("/path/to/sex_prediction_model/data/celltype_models/test_count_data_neuronal.csv", row.names = 1)
#### make character ID bin
testing$Identity_bin_char <- recode(testing$Identity_bin, `0` = "Male", `1` = "Female")
testing$Identity_bin_char <- factor(testing$Identity_bin_char, levels = c("Male", "Female"))
#### make ID bin a factor
testing$Identity_bin <- as.factor(testing$Identity_bin)

# Predictions ####
## logistic regression
lr_prediction <- predict(lr_model,testing[,1:54], type = "response")
## support vector machine
svm_prediction <- predict(svm_model,testing[,1:54], type = "prob")
## random forrest
rf_prediction <- predict(rf_model,testing[,1:54], type = "prob")
## multi-layer perceptron
mlp_prediction <- predict(mlp_model,testing[,1:54], type = "prob")
## chrY expression based prediction
chrY_prediction <- chrY_model$y.counts
## Xist expression based prediction
Xist_prediction <- Xist_model$Xist.counts


# ROC curves ####
## calculate ROC
lr_roc <- roc(testing$Identity_bin,lr_prediction, levels = c(1,0))
svm_roc <- roc(testing$Identity_bin_char, svm_prediction[,2], levels = c("Female", "Male"))
rf_roc <- roc(testing$Identity_bin_char, rf_prediction[,2], levels = c("Female", "Male"))
mlp_roc <- roc(testing$Identity_bin_char, mlp_prediction[,2], levels = c("Female", "Male"))
chrY_roc <- roc(testing$Identity_bin_char, chrY_prediction, levels = c("Female", "Male"))
Xist_roc <- roc(testing$Identity_bin_char, Xist_prediction, levels = c("Female", "Male"), direction = ">")

## plot ROC curves
g <- ggroc(data = list(`Chr Y` = chrY_roc,
                       `Xist` = Xist_roc,
                       `Logistic Regression` = lr_roc,
                       `SVM` = svm_roc,
                       `Random Forest` = rf_roc,
                       `MLP` = mlp_roc)) +
  geom_abline(slope = 1, intercept = 1, linetype = "dashed") +
  labs(color = "Model") +
  theme_bw()
ggsave(filename = "/path/to/sex_prediction_model/output/celltype_models/eval/ROC_curves_neuronal.pdf",
       plot = g + theme(text = element_text(size = 20)),
       height = 10,
       width = 12,
       device = "pdf")

## save AUC values
auc.table <- data.frame(AUC = c(chrY_roc[["auc"]] %>% as.numeric(),
                                Xist_roc[["auc"]] %>% as.numeric(),
                                lr_roc[["auc"]] %>% as.numeric(),
                                svm_roc[["auc"]] %>% as.numeric(),
                                rf_roc[["auc"]] %>% as.numeric(),
                                mlp_roc[["auc"]] %>% as.numeric()))
rownames(auc.table) <- c("Chr Y", "Xist", "Logistic Regression","SVM", "Random Forest", "MLP")
write.csv(auc.table, "/path/to/sex_prediction_model/output/celltype_models/eval/AUCs_table_neuronal.csv")

# Confusion Matrices ####
## make precitions using threshold
svm_prediction$class <- ifelse(svm_prediction$Female >0.5, "Female", "Male")
svm_prediction$class <- factor(svm_prediction$class, levels = c("Male", "Female"))

rf_prediction$class <- ifelse(rf_prediction$Female >0.5, "Female", "Male")
rf_prediction$class <- factor(rf_prediction$class, levels = c("Male", "Female"))

mlp_prediction$class <- ifelse(mlp_prediction$Female >0.5, "Female", "Male")
mlp_prediction$class <- factor(mlp_prediction$class, levels = c("Male", "Female"))

lr_prediction <- ifelse(lr_prediction >0.5, 1, 0)
lr_prediction <- as.factor(lr_prediction)

chrY_prediction <- factor(chrY_model$Sex.prediction, levels = c("Male", "Female"))

Xist_prediction <- factor(Xist_model$Sex.prediction, levels = c("Male", "Female"))


## make confusion matrices
svm_confusion <- caret::confusionMatrix(svm_prediction$class,testing$Identity_bin_char)
rf_confusion <- caret::confusionMatrix(rf_prediction$class,testing$Identity_bin_char)
mlp_confusion <- caret::confusionMatrix(mlp_prediction$class,testing$Identity_bin_char)
lr_confusion <- caret::confusionMatrix(lr_prediction, testing$Identity_bin)
chrY_confusion <- caret::confusionMatrix(chrY_prediction, testing$Identity_bin_char)
Xist_confusion <- caret::confusionMatrix(Xist_prediction, testing$Identity_bin_char)

## print confusion matrices to log
print("SVM confusion Matrix: ")
svm_confusion
cat("\n")

print("Random Forest confusion Matrix: ")
rf_confusion
cat("\n")

print("MLP confusion matrix: ")
mlp_confusion
cat("\n")

print("Logistic Regression confusion matrix: ")
lr_confusion
cat("\n")

print("Chr Y confusion matrix: ")
chrY_confusion
cat("\n")

print("Xist confusion matrix: ")
Xist_confusion
cat("\n")

## make accuracy table
acc.table <- data.frame(Accuracy = c(chrY_confusion[["overall"]][["Accuracy"]],
                                     Xist_confusion[["overall"]][["Accuracy"]],
                                     lr_confusion[["overall"]][["Accuracy"]],
                                     svm_confusion[["overall"]][["Accuracy"]],
                                     rf_confusion[["overall"]][["Accuracy"]],
                                     mlp_confusion[["overall"]][["Accuracy"]]))
rownames(acc.table) <- c("Chr Y","Xist", "Logistic Regression", "SVM", "Random Forest", "MLP")
write.csv(acc.table, "/path/to/sex_prediction_model/output/celltype_models/eval/Accuracy_table_neuronal.csv")

## stacked bar plot of prediction accuracies
### make list of confusion matrices
confusion.list <- list(ChrY = chrY_confusion,
                       Xist = Xist_confusion,
                       `Logistic Regression` = lr_confusion,
                       SVM = svm_confusion,
                       `Random Forest` = rf_confusion,
                       MLP = mlp_confusion)

### extract values to data frame with values for reference_prediction
confusion.df <- data.frame(model = c("Chr Y","Xist", "Logistic Regression", "SVM", "Random Forest", "MLP"),
                           Male_correct = lapply(confusion.list, function(x){x[["table"]][1,1]}) %>% unlist(),
                           Female_incorrect = lapply(confusion.list, function(x){x[["table"]][1,2]}) %>% unlist(),
                           Male_incorrect = lapply(confusion.list, function(x){x[["table"]][2,1]}) %>% unlist(),
                           Female_correct = lapply(confusion.list, function(x){x[["table"]][2,2]}) %>% unlist())

### convert to long format and split reference level and prediction
confusion.df.long <- confusion.df %>%
  pivot_longer(cols = Male_correct:Female_correct,
               names_to = "prediction",
               values_to = "count") %>%
  separate(col = prediction,
           into = c("reference","prediction"),
           sep = "_")

### convert variables to factors
confusion.df.long <- confusion.df.long %>% mutate(reference = factor(reference, levels = c("Male", "Female")),
                                                  prediction = factor(prediction, levels = c("incorrect","correct")),
                                                  model = factor(model, levels = rev(c("Chr Y","Xist", "Logistic Regression", "SVM", "Random Forest", "MLP"))))

### create stacked bar plot of predictions split by sex
confusion.plot <- ggplot(data = confusion.df.long, mapping = aes(x=model, y=count, fill=prediction)) + 
  geom_bar(position="fill", stat="identity") +
  facet_wrap( ~ reference) +
  theme_bw() +
  coord_flip() +
  labs(title = "Confuson plot", x = "Model", y = "Proportion") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())

### save
ggsave(plot = confusion.plot,
       file = "/path/to/sex_prediction_model/output/celltype_models/eval/confusionplot_neuronal.pdf",
       height = 7,
       width = 10,
       device = "pdf")

# sessionInfo
sessionInfo()
```

```{bash filename="overall_performance_neuronal_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=overall_performance_neuronal
#SBATCH --output=/path/to/sex_prediction_model/logs/overall_performance_neuronal_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/overall_performance_neuronal_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/celltype_models/overall_performance_neuronal.R
```


#### Non-neuronal
```{r filename="overall_performance_nonneuronal.R"}
# Setup ####
## libraries
library(randomForest)
library(kernlab)
library(RSNNS)
library(caret)
library(ROCR)
library(pROC)
library(ggplot2)
library(dplyr)
library(tidyr)

## set seed
set.seed(1234)

## data
### models
svm_model <- readRDS("/path/to/sex_prediction_model/data/celltype_models/models/svm_rad_model_nonneuronal.RDS")
rf_model <- readRDS("/path/to/sex_prediction_model/data/celltype_models/models/rf_model_nonneuronal.RDS")
mlp_model <- readRDS("/path/to/sex_prediction_model/data/celltype_models/models/mlpwdml_model_nonneuronal.RDS")
lr_model <- readRDS("/path/to/sex_prediction_model/data/celltype_models/models/lr_model_nonneuronal.RDS")
chrY_model <- read.csv("/path/to/sex_prediction_model/output/celltype_models/Yclass.predictions.nonneuronal.csv", row.names = 1)
Xist_model <- read.csv("/path/to/sex_prediction_model/output/celltype_models/Xist.class.predictions.nonneuronal.csv", row.names = 1)

### testing data
testing <- read.csv("/path/to/sex_prediction_model/data/celltype_models/test_count_data_nonneuronal.csv", row.names = 1)
#### make character ID bin
testing$Identity_bin_char <- recode(testing$Identity_bin, `0` = "Male", `1` = "Female")
testing$Identity_bin_char <- factor(testing$Identity_bin_char, levels = c("Male", "Female"))
#### make ID bin a factor
testing$Identity_bin <- as.factor(testing$Identity_bin)

# Predictions ####
## logistic regression
lr_prediction <- predict(lr_model,testing[,1:234], type = "response")
## support vector machine
svm_prediction <- predict(svm_model,testing[,1:234], type = "prob")
## random forrest
rf_prediction <- predict(rf_model,testing[,1:234], type = "prob")
## multi-layer perceptron
mlp_prediction <- predict(mlp_model,testing[,1:234], type = "prob")
## chrY expression based prediction
chrY_prediction <- chrY_model$y.counts
## Xist expression based prediction
Xist_prediction <- Xist_model$Xist.counts


# ROC curves ####
## calculate ROC
lr_roc <- roc(testing$Identity_bin,lr_prediction, levels = c(1,0))
svm_roc <- roc(testing$Identity_bin_char, svm_prediction[,2], levels = c("Female", "Male"))
rf_roc <- roc(testing$Identity_bin_char, rf_prediction[,2], levels = c("Female", "Male"))
mlp_roc <- roc(testing$Identity_bin_char, mlp_prediction[,2], levels = c("Female", "Male"))
chrY_roc <- roc(testing$Identity_bin_char, chrY_prediction, levels = c("Female", "Male"))
Xist_roc <- roc(testing$Identity_bin_char, Xist_prediction, levels = c("Female", "Male"), direction = ">")

## plot ROC curves
g <- ggroc(data = list(`Chr Y` = chrY_roc,
                       `Xist` = Xist_roc,
                       `Logistic Regression` = lr_roc,
                       `SVM` = svm_roc,
                       `Random Forest` = rf_roc,
                       `MLP` = mlp_roc)) +
  geom_abline(slope = 1, intercept = 1, linetype = "dashed") +
  labs(color = "Model") +
  theme_bw()
ggsave(filename = "/path/to/sex_prediction_model/output/celltype_models/eval/ROC_curves_nonneuronal.pdf",
       plot = g + theme(text = element_text(size = 20)),
       height = 10,
       width = 12,
       device = "pdf")

## save AUC values
auc.table <- data.frame(AUC = c(chrY_roc[["auc"]] %>% as.numeric(),
                                Xist_roc[["auc"]] %>% as.numeric(),
                                lr_roc[["auc"]] %>% as.numeric(),
                                svm_roc[["auc"]] %>% as.numeric(),
                                rf_roc[["auc"]] %>% as.numeric(),
                                mlp_roc[["auc"]] %>% as.numeric()))
rownames(auc.table) <- c("Chr Y", "Xist", "Logistic Regression","SVM", "Random Forest", "MLP")
write.csv(auc.table, "/path/to/sex_prediction_model/output/celltype_models/eval/AUCs_table_nonneuronal.csv")

# Confusion Matrices ####
## make precitions using threshold
svm_prediction$class <- ifelse(svm_prediction$Female >0.5, "Female", "Male")
svm_prediction$class <- factor(svm_prediction$class, levels = c("Male", "Female"))

rf_prediction$class <- ifelse(rf_prediction$Female >0.5, "Female", "Male")
rf_prediction$class <- factor(rf_prediction$class, levels = c("Male", "Female"))

mlp_prediction$class <- ifelse(mlp_prediction$Female >0.5, "Female", "Male")
mlp_prediction$class <- factor(mlp_prediction$class, levels = c("Male", "Female"))

lr_prediction <- ifelse(lr_prediction >0.5, 1, 0)
lr_prediction <- as.factor(lr_prediction)

chrY_prediction <- factor(chrY_model$Sex.prediction, levels = c("Male", "Female"))

Xist_prediction <- factor(Xist_model$Sex.prediction, levels = c("Male", "Female"))


## make confusion matrices
svm_confusion <- caret::confusionMatrix(svm_prediction$class,testing$Identity_bin_char)
rf_confusion <- caret::confusionMatrix(rf_prediction$class,testing$Identity_bin_char)
mlp_confusion <- caret::confusionMatrix(mlp_prediction$class,testing$Identity_bin_char)
lr_confusion <- caret::confusionMatrix(lr_prediction, testing$Identity_bin)
chrY_confusion <- caret::confusionMatrix(chrY_prediction, testing$Identity_bin_char)
Xist_confusion <- caret::confusionMatrix(Xist_prediction, testing$Identity_bin_char)

## print confusion matrices to log
print("SVM confusion Matrix: ")
svm_confusion
cat("\n")

print("Random Forest confusion Matrix: ")
rf_confusion
cat("\n")

print("MLP confusion matrix: ")
mlp_confusion
cat("\n")

print("Logistic Regression confusion matrix: ")
lr_confusion
cat("\n")

print("Chr Y confusion matrix: ")
chrY_confusion
cat("\n")

print("Xist confusion matrix: ")
Xist_confusion
cat("\n")

## make accuracy table
acc.table <- data.frame(Accuracy = c(chrY_confusion[["overall"]][["Accuracy"]],
                                     Xist_confusion[["overall"]][["Accuracy"]],
                                     lr_confusion[["overall"]][["Accuracy"]],
                                     svm_confusion[["overall"]][["Accuracy"]],
                                     rf_confusion[["overall"]][["Accuracy"]],
                                     mlp_confusion[["overall"]][["Accuracy"]]))
rownames(acc.table) <- c("Chr Y","Xist", "Logistic Regression", "SVM", "Random Forest", "MLP")
write.csv(acc.table, "/path/to/sex_prediction_model/output/celltype_models/eval/Accuracy_table_nonneuronal.csv")

## stacked bar plot of prediction accuracies
### make list of confusion matrices
confusion.list <- list(ChrY = chrY_confusion,
                       Xist = Xist_confusion,
                       `Logistic Regression` = lr_confusion,
                       SVM = svm_confusion,
                       `Random Forest` = rf_confusion,
                       MLP = mlp_confusion)

### extract values to data frame with values for reference_prediction
confusion.df <- data.frame(model = c("Chr Y","Xist", "Logistic Regression", "SVM", "Random Forest", "MLP"),
                           Male_correct = lapply(confusion.list, function(x){x[["table"]][1,1]}) %>% unlist(),
                           Female_incorrect = lapply(confusion.list, function(x){x[["table"]][1,2]}) %>% unlist(),
                           Male_incorrect = lapply(confusion.list, function(x){x[["table"]][2,1]}) %>% unlist(),
                           Female_correct = lapply(confusion.list, function(x){x[["table"]][2,2]}) %>% unlist())

### convert to long format and split reference level and prediction
confusion.df.long <- confusion.df %>%
  pivot_longer(cols = Male_correct:Female_correct,
               names_to = "prediction",
               values_to = "count") %>%
  separate(col = prediction,
           into = c("reference","prediction"),
           sep = "_")

### convert variables to factors
confusion.df.long <- confusion.df.long %>% mutate(reference = factor(reference, levels = c("Male", "Female")),
                                                  prediction = factor(prediction, levels = c("incorrect","correct")),
                                                  model = factor(model, levels = rev(c("Chr Y","Xist", "Logistic Regression", "SVM", "Random Forest", "MLP"))))

### create stacked bar plot of predictions split by sex
confusion.plot <- ggplot(data = confusion.df.long, mapping = aes(x=model, y=count, fill=prediction)) + 
  geom_bar(position="fill", stat="identity") +
  facet_wrap( ~ reference) +
  theme_bw() +
  coord_flip() +
  labs(title = "Confuson plot", x = "Model", y = "Proportion") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())

### save
ggsave(plot = confusion.plot,
       file = "/path/to/sex_prediction_model/output/celltype_models/eval/confusionplot_nonneuronal.pdf",
       height = 7,
       width = 10,
       device = "pdf")

# sessionInfo
sessionInfo()
```

```{bash filename="overall_performance_nonneuronal_run.R"}
#!/bin/bash
#
#SBATCH --job-name=overall_performance_nonneuronal
#SBATCH --output=/path/to/sex_prediction_model/logs/overall_performance_nonneuronal_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/overall_performance_nonneuronal_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/celltype_models/overall_performance_nonneuronal.R
```


## NAc application
Performance on new or unseen data, called generalizability, is a critical measure of a model's utility. To validate that models learned robust cell sex classification rules that could be applied to other datasets, we measured the AUC-ROC and accuracy of model predictions in an orthogonal snRNA-seq experiment from the rat nucleus accumbens (NAc) [Phillips et al, 2023](https://doi.org/10.1016/j.mcn.2023.103849). Unlike the VTA, the NAc is largely composed of GABAergic medium spiny neurons (in addition to cholinergic and GABAergic interneurons), yet also contains similar glial cell types. This dataset contains 39,254 cells of 16 transcriptionally defined cell types from 32 rats (16M/16F).

### Overall Performance
```{r filename="NAc_integrated_overall_performance.R"}
# Setup ####
## libraries
library(Seurat)
library(caret)
library(randomForest)
library(kernlab)
library(RSNNS)
library(ROCR)
library(pROC)
library(ggplot2)
library(dplyr)
library(tidyr)

## set seed
set.seed(1234)

## functions
### Chr Y classification
y.count <- function(srat.object){
  # load gene expression count data
  srat.counts <- as.data.frame(t(as.matrix(GetAssayData(object = srat.object, slot = "data", assay = "RNA"))))
  
  # load gene annotations
  Rn7.gtf <- rtracklayer::import("/path/to/sex_prediction_model/data/Rattus_norvegicus.mRatBN7.2.105.gtf")
  Rn7.gtf <- as.data.frame(Rn7.gtf)
  
  # select Y chromosome genes
  y.genes <- Rn7.gtf %>% #from Rn7 gene annotations
    filter(seqnames == "Y") %>% #filter for chrY only
    select(gene_id, gene_name) %>% #select gene ids and names
    mutate(gene_name = coalesce(gene_name, gene_id)) %>% #replace NA name values with gene ID
    pull(gene_name) %>% #pull gene name values
    unique() #only unique values, returns 27 genes
  
  # create cumulative expresion of Y genes
  y.counts <- srat.counts %>%
    select(any_of(y.genes)) %>%
    rowSums() %>% data.frame()
  ### set column name
  colnames(y.counts) <- c("y.counts")
  
  return(y.counts)
}
y.count.classify <- function(srat.object, threshold){
  srat.object$y.counts <- y.count(srat.object)
  classifications <- case_when(srat.object$y.counts > threshold ~ "Male",
                               TRUE ~ "Female")
  return(classifications)
}

### Xist classification
Xist.count <- function(srat.object){
  # load gene expression count data
  Xist.counts <- as.data.frame(t(as.matrix(GetAssayData(object = srat.object, slot = "data", assay = "RNA")))) %>%
    pull("ENSRNOG00000065796") # pull out Xist (named as ENSRNOG00000065796)
  
  return(Xist.counts)
}
Xist.count.classify <- function(srat.object, threshold){
  srat.object$Xist.counts <- Xist.count(srat.object)
  classifications <- case_when(srat.object$Xist.counts > threshold ~ "Female",
                               TRUE ~ "Male")
  return(classifications)
}

## data
### NAc testing data
testing.NAc <- readRDS("/data/project/daylab/2019-JD-0040/MCN_Code/Objects/NAc_Combo_Integrated.RDS")
### model genes
confirmed.genes <- read.csv("/path/to/sex_prediction_model/data/Boruta_final_decisions.csv") %>% 
  filter(finalDecision == "Confirmed") %>%
  pull(variable)
### models
svm_model <- readRDS("/path/to/sex_prediction_model/data/models/svm_rad_model.RDS")
rf_model <- readRDS("/path/to/sex_prediction_model/data/models/rf_model.RDS")
mlp_model <- readRDS("/path/to/sex_prediction_model/data/models/mlpwdml_model.RDS")
lr_model <- readRDS("/path/to/sex_prediction_model/data/models/lr_model.RDS")

# NAc object preparation ####
## extract count matrices
testing.NAc.df <- as.data.frame(t(as.matrix(GetAssayData(object = testing.NAc, slot = "data",assay = "RNA")))) %>% 
  select(any_of(confirmed.genes))
### make sure cells are in the same order
all(names(Idents(testing.NAc)) == rownames(testing.NAc.df)) #TRUE 
### replace gene names that have "-" with "." to match gene name form the VTA models expect
colnames(testing.NAc.df) <- gsub("-", ".", colnames(testing.NAc.df))

## add sex identity columns
### character column
testing.NAc.df$Identity_bin_char <- factor(testing.NAc$Sex, levels = c("Male", "Female"))
### binary columns 
testing.NAc.df$Identity_bin <- ifelse(testing.NAc.df$Identity_bin_char  == "Female",
                                      1, #Females are 1
                                      0) #Males are 0
testing.NAc.df$Identity_bin <- as.factor(testing.NAc.df$Identity_bin)


# Make predictions ####
## logistic regression
lr_prediction <- predict(lr_model,testing.NAc.df[,1:285], type = "response")
## support vector machine
svm_prediction <- predict(svm_model,testing.NAc.df[,1:285], type = "prob")
## random forest
rf_prediction <- predict(rf_model,testing.NAc.df[,1:285], type = "prob")
## multi-layer perceptron
mlp_prediction <- predict(mlp_model,testing.NAc.df[,1:285], type = "prob")
## chrY expression based prediction
chrY_prediction <- data.frame(cell = names(Idents(testing.NAc)),
                              sex = testing.NAc$Sex,
                              counts = y.count(testing.NAc),
                              prediction = y.count.classify(testing.NAc,0))
chrY_prediction$prediction <- factor(chrY_prediction$prediction, levels = c("Male", "Female"))
## Xist expression based prediction
Xist_prediction <- data.frame(cell = names(Idents(testing.NAc)),
                              sex = testing.NAc$Sex,
                              counts = Xist.count(testing.NAc),
                              prediction = Xist.count.classify(testing.NAc,0))
Xist_prediction$prediction <- factor(Xist_prediction$prediction, levels = c("Male", "Female"))


# ROC + AUC ####
lr_roc <- roc(testing.NAc.df$Identity_bin,lr_prediction, levels = c(1,0))
svm_roc <- roc(testing.NAc.df$Identity_bin_char, svm_prediction[,2], levels = c("Female", "Male"))
rf_roc <- roc(testing.NAc.df$Identity_bin_char, rf_prediction[,2], levels = c("Female", "Male"))
mlp_roc <- roc(testing.NAc.df$Identity_bin_char, mlp_prediction[,2], levels = c("Female", "Male"))
chrY_roc <- roc(testing.NAc.df$Identity_bin_char, chrY_prediction$y.counts, levels = c("Female", "Male"))
Xist_roc <- roc(testing.NAc.df$Identity_bin_char, Xist_prediction$counts, levels = c("Female", "Male"), direction = ">")

## plot ROC curves
g <- ggroc(data = list(`Chr Y` = chrY_roc,
                       `Xist` = Xist_roc,
                       `Logistic Regression` = lr_roc,
                       `SVM` = svm_roc,
                       `Random Forest` = rf_roc,
                       `MLP` = mlp_roc)) +
  geom_abline(slope = 1, intercept = 1, linetype = "dashed") +
  labs(color = "Model") +
  theme_bw()
ggsave(filename = "/path/to/sex_prediction_model/output/NAc_evaluation/ROC_curves.pdf",
       plot = g + theme(text = element_text(size = 20)),
       height = 10,
       width = 12,
       device = "pdf")

## save AUC values
auc.table <- data.frame(AUC = c(chrY_roc[["auc"]] %>% as.numeric(),
                                Xist_roc[["auc"]] %>% as.numeric(),
                                lr_roc[["auc"]] %>% as.numeric(),
                                svm_roc[["auc"]] %>% as.numeric(),
                                rf_roc[["auc"]] %>% as.numeric(),
                                mlp_roc[["auc"]] %>% as.numeric()))
rownames(auc.table) <- c("Chr Y", "Xist", "Logistic Regression","SVM", "Random Forest", "MLP")
write.csv(auc.table, "/path/to/sex_prediction_model/output/NAc_evaluation/AUCs_table.csv")

# Confusion matrices ####
## make precitions using threshold
svm_prediction$class <- ifelse(svm_prediction$Female >0.5, "Female", "Male")
svm_prediction$class <- factor(svm_prediction$class, levels = c("Male", "Female"))

rf_prediction$class <- ifelse(rf_prediction$Female >0.5, "Female", "Male")
rf_prediction$class <- factor(rf_prediction$class, levels = c("Male", "Female"))

mlp_prediction$class <- ifelse(mlp_prediction$Female >0.5, "Female", "Male")
mlp_prediction$class <- factor(mlp_prediction$class, levels = c("Male", "Female"))

lr_prediction <- ifelse(lr_prediction >0.5, 1, 0)
lr_prediction <- as.factor(lr_prediction)

## make confusion matrices
svm_confusion <- caret::confusionMatrix(svm_prediction$class, testing.NAc.df$Identity_bin_char)
rf_confusion <- caret::confusionMatrix(rf_prediction$class, testing.NAc.df$Identity_bin_char)
mlp_confusion <- caret::confusionMatrix(mlp_prediction$class, testing.NAc.df$Identity_bin_char)
lr_confusion <- caret::confusionMatrix(lr_prediction, testing.NAc.df$Identity_bin)
chrY_confusion <- caret::confusionMatrix(chrY_prediction$prediction, testing.NAc.df$Identity_bin_char)
Xist_confusion <- caret::confusionMatrix(Xist_prediction$prediction, testing.NAc.df$Identity_bin_char)

## print confusion matrices to log
print("SVM confusion Matrix: ")
svm_confusion
cat("\n")

print("Random Forest confusion Matrix: ")
rf_confusion
cat("\n")

print("MLP confusion matrix: ")
mlp_confusion
cat("\n")

print("Logistic Regression confusion matrix: ")
lr_confusion
cat("\n")

print("Chr Y confusion matrix: ")
chrY_confusion
cat("\n")

print("Xist confusion matrix: ")
Xist_confusion
cat("\n")

## make accuracy table
acc.table <- data.frame(Accuracy = c(chrY_confusion[["overall"]][["Accuracy"]],
                                     Xist_confusion[["overall"]][["Accuracy"]],
                                     lr_confusion[["overall"]][["Accuracy"]],
                                     svm_confusion[["overall"]][["Accuracy"]],
                                     rf_confusion[["overall"]][["Accuracy"]],
                                     mlp_confusion[["overall"]][["Accuracy"]]))
rownames(acc.table) <- c("Chr Y","Xist", "Logistic Regression", "SVM", "Random Forest", "MLP")
write.csv(acc.table, "/path/to/sex_prediction_model/output/NAc_evaluation/Accuracy_table.csv")

## stacked bar plot of prediction accuracies
### make list of confusion matrices
confusion.list <- list(ChrY = chrY_confusion,
                       Xist = Xist_confusion,
                       `Logistic Regression` = lr_confusion,
                       SVM = svm_confusion,
                       `Random Forest` = rf_confusion,
                       MLP = mlp_confusion)

### extract values to data frame with values for reference_prediction
confusion.df <- data.frame(model = c("Chr Y","Xist", "Logistic Regression", "SVM", "Random Forest", "MLP"),
                           Male_correct = lapply(confusion.list, function(x){x[["table"]][1,1]}) %>% unlist(),
                           Female_incorrect = lapply(confusion.list, function(x){x[["table"]][1,2]}) %>% unlist(),
                           Male_incorrect = lapply(confusion.list, function(x){x[["table"]][2,1]}) %>% unlist(),
                           Female_correct = lapply(confusion.list, function(x){x[["table"]][2,2]}) %>% unlist())

### convert to long format and split reference level and prediction
confusion.df.long <- confusion.df %>%
  pivot_longer(cols = Male_correct:Female_correct,
               names_to = "prediction",
               values_to = "count") %>%
  separate(col = prediction,
           into = c("reference","prediction"),
           sep = "_")

### convert variables to factors
confusion.df.long <- confusion.df.long %>% mutate(reference = factor(reference, levels = c("Male", "Female")),
                                                  prediction = factor(prediction, levels = c("incorrect","correct")),
                                                  model = factor(model, levels = rev(c("Chr Y","Xist", "Logistic Regression", "SVM", "Random Forest", "MLP"))))

### create stacked bar plot of predictions split by sex
confusion.plot <- ggplot(data = confusion.df.long, mapping = aes(x=model, y=count, fill=prediction)) + 
  geom_bar(position="fill", stat="identity") +
  facet_wrap( ~ reference) +
  theme_bw() +
  coord_flip() +
  labs(title = "Confuson plot", x = "Model", y = "Proportion") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())

### save
ggsave(plot = confusion.plot,
       file = "/path/to/sex_prediction_model/output/NAc_evaluation/confusionplot.pdf",
       height = 7,
       width = 10,
       device = "pdf")

# sessionInfo ####
sessionInfo()
```

```{bash filename="NAc_integrated_overall_performance_run.sh"}
#!/bin/bash
#
#SBATCH --job-name=NAc_integrated_overall_performance
#SBATCH --output=/path/to/sex_prediction_model/logs/NAc_integrated_overall_performance_out.txt
#SBATCH --error=/path/to/sex_prediction_model/logs/NAc_integrated_overall_performance_error.txt
#SBATCH --ntasks=1
#SBATCH --partition=express
#SBATCH --time=2:00:00
#SBATCH --cpus-per-task=8
#SBATCH --mem-per-cpu=16g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=user@mail.edu

# Load Modules
module load R/4.2.0-foss-2021a-bare

# Run script
Rscript /path/to/sex_prediction_model/sex-prediction-model/scripts/NAc_evaluation/NAc_integrated_overall_performance.R
```

